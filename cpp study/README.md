
# C++ 모던 공부

- 현재 C++ 모던 어디까지 나왔는지 한번 정리해보기
- 이펙티브 C++ 공부하기
- [More C++ Idioms](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms) 공부하기



## C/ C++ 실행 방식, 소스 파일, 컴파일, 링크 ,링커, 실행파일

1. 소스 파일(source file)의 작성

2. 선행처리기(preprocessor)에 의한 선행처리

3. 컴파일러(compiler)에 의한 컴파일

4. 링커(linker)에 의한 링크

5. 실행 파일(executable file)의 생성

# 업캐스팅, 다운캐스팅

```
자식클래스는 부모클래스의 모든 특성을 받습니다.
업캐스팅은 자식클래스의 객체가 부모클래스로 형변환하는걸 말하는데
부모형 클래스로 변환하면 그 이후에 자식클래스의 특성을 쓰면 컴파일 타임 오류납니다.

다운캐스팅은 자신의 고유 특성을 잃은 자식 클래스를 다시 원상태로 복구해주는겁니다.
업캐스팅된 것을 다시 돌려주는 겁니다.

즉, 다운캐스팅은 업캐스팅 된것을 다운캐스팅하여서 다시 자식클래스의 성질로 돌려주는겁니다.

1. 업캐스팅 먼저 선행
2.  다운캐스팅

* 바로 부모클래스의 객체를 자식클래스로 그냥 형변환할 경우는
 컴파일 시점에 오류가 발생하지않아도 런타임 오류를발생합니다. 
즉, 바로 다운캐스팅하는 경우는 오류를 발생하기때문에 쓰지않습니다.
```

##  C++ 캐스팅 4가지 설명

- 여기가 엄청 정리가 잘되있어서 [참고](https://ju3un.github.io/c++-type-casting/) 하였습니다.
- static_cast, reinterpret_cast, const_cast, dynamic_cast 캐스팅 4종류에 정리.

``` C++
int i = 0;
char ch1 = i;       // 묵시적 형 변환(Implicit Cast)
char ch2 = (char)i; // 명시적 형 변환(Explicit Cast)
```

1. static_cast

- 가장 보편적으로 사용되는, 논리적으로 변환 가능한 타입을 변환하는 연산자
- 컴파일(Compile) 시점에 발생
- 묵시적 형 변환(Implicit Cast)과 같은 맥락

- Q. 묵시적 형 변환은 문법적인 키워드가 존재하지 않는데, static_cast이 묵시적 형 변환과 같은 의미라니?
 * 컴파일러가 값을 변환하기 위해 기계어 코드를 만들어 내는 컴파일 시점에 형 변환이 일어나는 관점 에서 같은 맥락

- Q. 그렇다면 static_cast(정적 캐스팅)과 묵시적 형 변환과의 차이는?
```
"상속 관계에 있는 포인터끼리 변환이 가능하다"는 점이다.
그러나, 다운캐스트(Downcast)의 경우 Unsafe 하다. (Unsafe Downcasting)
```
- cf. new_type으로 void* 형이 올 수 있지만 return 값이 없다.


2. reinterpret_cast

- 임의의 포인터끼리 변환 허용 (연관성이 없는 포인터 타입의 형 변환 가능) (static_cast와의 차이점)
- 강제 형 변환으로 문법적으로 변환을 허용하는 것이지, 논리적으로 안전한 타입 연산자는 아님
- expression에 해당하는 것을 new_type으로 비트 단위로 강제 형 변환
- ex) 주로 정수형 -> 포인터 또는 포인터 -> 정수형 변환하는 작업에 주로 사용함

3. const_cast

- 포인터 타입, 참조형에 대해서만 사용되며 동일한 타입에 대해서만 허용함
- const 속성이나 volatile 속성을 잠깐 제거할 때 사용

4. dynamic_cast

- RTTI(Runtime Type Information)
```
C++ 컴파일러 내에 포함되어 있는 기능으로, 객체의 유형을 실행 시에 결정할 수 있도록 허용하는 것을 의미한다.
다른 말로는 실행 중에 타입의 정보를 가지고 온다는 의미로 표현할 수도 있다.

메모리 상주 객체에 유형 정보를 추가하여, 실행 시스템은 객체의 캐스트(=형 변환)가 유효한 지 여부를 확실히 하기 위해 특정 객체의 유형을 결정할 수 있다.

RTTI는 객체를 동적으로 변화시킬 수 있는 Polymorphism 능력이라고 이해하면 된다.
타입 캐스팅에서 이 용어를 다룬 이유는, 바로 dynamic_cast 연산자가 이 요소 중 하나이기 때문이다.
```

- 주로 다운 캐스팅으로 사용되는 연산자 (부모 클래스 포인터에서 -> 자식 클래스 포인터로 다운캐스팅)
- 다른 캐스트와 달리 런타임 시간에 다운 캐스팅이 가능한지 능동적으로 판단하기 때문에 런타임 비용이 높음.-
- 형 변환 성공 시 : 변환된 값 return
- 형 변환 실패 시 : 널 포인터(null pointer) 또는 예외(Exception) return


##  객체지향(OOP) 특징 말하고 가상함수에 대해서 설명해보아라. (소멸자와 관련되어서 설명)

- C++ OOP
1. Class 클래스
2. Object 객체
3. Abstraction 추상화
4. Encapsulation 캡슐화
5. Inheritance 상속
6. Polymorphism 다형성

- 가상함수

- 순수 가상 함수는 인터페이스(Interface)를 자식 클래스에게 전달하기 위해 사용하는 함수입니다.

- 일반(단순) 가상 함수는 인터페이스(Interface) + 함수의 선언(내부 구현) 까지 자식 클래스에게 전달하기 위해 사용하는 함수입니다.

- C++ 가상 함수 (virtual) - 가상 소멸자

- 가상 소멸자(중요)
```
클래스에 가상 함수를 정의할 때 주의할 점은 소멸자도 가상함수로 만들어야 한다는 점입니다.
동적으로 생성한 자식 클래스 객체를 부모 클래스 포인터로 가리키고 있을 때 동적으로 생성한 객체를 해제하려면 기본 클래스 포인터로부터 delete 해야 합니다.
```

## 스마트 포인터 3가지 종류와 왜 각각 쓰는지 설명

- 스마트 포인터(Smart Pointer)
1. RALL(Resource Acquisition Is Initialization) 원칙
```
안전하게 자원을 사용하기 위한, C++에서 자주 쓰는 패턴
객체가 사용되는 스코프(범위)를 벗어나면, 자원을 해제해주는 기법
ex. 함수 내의 지역변수(stack에 할당된 메모리)는 그 함수가 끝나는 시점에서 메모리가 해제되는 원리
```

2. 자원 관리 객체
```
자원을 획득한 후 자원 관리 객체, 즉 스마트 포인터(Smart Pointer)에 넘겨준다.
자원 관리 객체는 자신의 소멸자(스마트 포인터의 소멸자에 존재하는 delete 연산자)를 이용해서 자원을 해제한다.
포인터처럼 동작하는 클래스 템플릿으로, 사용이 끝난 메모리를 자동으로 해제해 준다.
기존 포인터 타입에서 자원 관리 기능(메모리 자원 관리, 경계 검사 등)이 추가된 추상 데이터 타입
원본 삭제 및 참조 카운트(Reference Count)를 이용해 댕글링 포인터(Dangling Pointer)가 되는 것을 막는다.
(cf. Dangling Pointer : 해제된 동적 메모리 영역을 가리키고 있는 포인터 / stack에서 사라진 메모리를 가리키는 포인터)
```

1. unique_ptr

- 복사X, 이동만 가능(복사 생성자, 복사 대입 연산자 구현되어 있지 않음)
- 소유권 독점 방식 사용(소유권 이전 시 std::move() 사용)
- 해당 객체의 소유권을 가지고 있을 때만, 소멸자가 해당 객체를 삭제할 수 있음
- C++14 이후 makeunique() 함수를 사용하여 uniqueptr 객체를 안전하게 생성할 수 있음

2.  shared_ptr
- 참조 카운팅 방식 스마트 포인터(Reference Counting Smart Pointer)
-  소유권이 아닌 공유 방식 사용
- 참조 카운트가 0이 될 때만, 해당 객체가 자동으로 삭제됨

3. weak_ptr
- shared_ptr와 함께 사용할 수 있는 스마트 포인터
- shared_ptr의 문제점(상호 참조로 인해 객체가 삭제되지 않는 상황)을 보완하기 위해 사용되는 특수 포인터
- sharedptr을 weakptr로 참조 시, 참조 카운트에 포함되지 않음
- 포인터에 대한 직접적인 접근이 불가능함


##  오버로딩과 오버라이딩 차이

- 오버로딩(Overloading) - 함수 중복 정의

- 오버로딩은 같은 이름의 함수에 매개변수를 다르게 사용하여 매개 변수에 따라 다른 함수가 실행되는 것.

- 오버라이딩(Overriding) - 함수 재정의

- 오버라이딩은 상속받았을때 부모클래스의 함수를 사용하지 않고 다른 기능을 실행할때 함수를 자식클래스에 같은 이름, 매개변수로 재정의 해서 사용하는 것.


## call by value call by reference 차이
- 함수의 호출은 두 가지 있다.

- Call by value(값에 의한 호출)
- Call by reference(참조에 의한 호출)


- Call by value(값에 의한 호출)
```
장점 : 복사하여 처리하기 때문에 안전하다. 원래의 값이 보존이 된다.
단점 : 복사를 하기 때문에 메모리가 사용량이 늘어난다.
```
``` C++
#include <stdio.h>
 
void swap(int num1, int num2)
{
    int temp = num1;
    num1 = num2;
    num2 = temp;
}
void main()
{
    int a = 20, b = 60;
    swap(a, b);
    printf("a: %d, b: %d", a, b); // 20 ,60이 나온다.
}
```


- Call by reference(참조에 의한 호출)
```
장점 : 복사하지 않고 직접 참조를 하기에 빠르다.
단점 : 직접 참조를 하기에 원래 값이 영향을 받는다.(리스크)
```


``` C++
#include <stdio.h>
 
void swap(int &num1, int &num2)
{
    int temp = num1;
    num1 = num2;
    num2 = temp;
}
void main()
{
    int a = 20, b = 60;
    swap(a, b);
    printf("a: %d, b: %d", a, b); //60, 20바뀐다.
}
```

##  스택과 힙의 차이


## 벡터(배열)과 리스트 차이


## 퀵소트 설명, 코드 짜보기

## C++ 과 자바의 차이


## 객체 지향과 절차지향 차이


## new 와 malloc 차이


## STL의 맵과 일반 해쉬 맵의 차이가 뭔가요?



## template 관련


## R-value vs L-value 차이


##  move ,forward



## 모던 C++ 람다함수, SFINAE, constexpr


##  최신 모던 C++ 알고 있는가?