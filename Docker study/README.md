# 따라하며 배우는 도커와 CI환경 인프런 강의

- [git 주소 참고](https://github.com/jaewonhimnae/docker-codes)

## 4월 17일 ~ 23일 강의 수강, 정리 예정

- 실습과 전반적인 흐름을 이해할 예정

## 다음 책을 참고하면서 도커와 쿠버네티스를 추가적 실습할 예정

- 15단계로 배우는 도커와 쿠버네티스

## 도커 기본

## 1. 
1. 도커를 쓰는 이유

- 결론적으로 어떠한 프로그램을 다운받는 과정에서 굉장히 간단하게 만들기 위해서

- 레디스 설치 하는 것으로 시작

- 실제 리눅스에 깔기 위해서 실행환경을 갖춰야되기 때문에 에러를 먼저 만남eh

- 하지만 도커는 docker run -it redis으로 끝남

## 1. 2. 도커란 무엇인가?

- 컨테이너를 사용하여 응용프로그램을 더 쉽게만들고 배포하고 실행할수 있도록 설계한 도구이며 컨테이너 기반의 오픈소스 가상화 플랫폼이다.

## 1. 3. 도커이미지와 도커 컨테이너 정의

- 컨테이너는 코드와 모든 조옥성을 패키지화하여 응용 프로그램이 컴퓨팅 환경에서 다른 컴퓨팅환경으로 빠르고 안정적으로 실행되도록하는 소프트웨어의 표준이다.

- 컨테이너 이미지는 코드, 런타임, 시스템 도구, 시스테 라이브러리 및 설정과 같은 응용 프로그램을 실행하는데 필요한 모든것을 포함하는 가볍고 독립적이며 실행가능한 소프트웨어 패키지임

- 컨테이너 이미지는 런타임에 컨테이너가 되고 도커 컨테이너의 경우 도커 엔진에서 실행될때 이미지가 컨테이너가 된다. (이미지는 종속성, 컨테이너의 인스턴스)

1. 먼저 도커 CLI에서 커맨드를 입력한다

2. 도커 서버(도커 데몬)이 그 커멘드를 받아서 그것에 따라 이미지를 생성하든 컨테이너를 싱행하든 모든 작업을 하게 된다.

- 도커 client(CLI) - 도커 Server (Daemon)

- docker run hello-world

- 컴퓨터 도커 클라이언트 -> 도커서버 -> hello-world 이미지가 있나요?

- -> 도커허브 (이미지들을 보관) <-hello-world 

## 1. 4. 도커와 기존 가상화 기술과의 차이를 통한 컨테이너 이해

1. 가상화 기술이 나오기 전

- 한대의 서버를 하나의 용도로만이 사용 

- 남는 공간 그대로 방치

- 하나의 서버에 하나의 운영체제, 하나의 프로그램만을 운영 안정적 but 비효율적

2. 하이퍼바이저 기반의 가상화 출현

- 논리적으로 공간을 분할하여 VM이라는 독립적인 가상환경 서버 이용가능

- 하이퍼바이저는 호스트 시스템에서 다수의 OS를 구동할수 있게하는 소프트웨어

- 하드웨어를 가상화하면서 하드웨어와 각각의 VM을 모니터링하는 중간관리자임.

- 네이티브 하이퍼바이저 - 하드웨어 -> 하이퍼바이저 -> OS

- 호스트형 하이퍼바이저 - 하드웨어->OS ->하이퍼바이저 ->OS

- 도커 컨테이너와 가상기술이랑 공통점, 차이점

- 공통점 :기본 하드웨어에서 격리된 환경 내에 어플리케이션을 배치하는 방법

- 차이점 : 얼마나 격리시키는지 차이점

- 가상화기술 (VM)은 게스트 OS가 있어 무거움, 도커는 없어서 가벼움

- 컨테이너 : 카카오톡 -> 커널 ->하드디스크 CPU, 네트워크 , RAM

## 1.5. 이미지로 컨테이너 만들기

- 이미지는 응용 프로그램을 실행하는데 필요한 모든것을 포함하고 있음

- 그러면 뭐가 필요하지?

1.  컨테이너가 시작될때 실행되는 명령어 ex) run kakaotalk

2. 파일 스냅샷 ex)컨테이너에서 카카오톡을 싱행하고 싶다면 카카오톡 스냅샷

* 파일 스냅샷은 디렉토리나 파일을 카피한것

3. 이미지에서 가지고있는 명령어를 사용해서 카카오톡을 실행시켜줌

- 이미지로 컨테이너 만드는 순서

1. 도커 클라이언트에서 docker run <이미지> 입력해줌

## 1. 6. C-group, 네임스페이스를 도커환경에서 쓸 수 있는 이유

- 컨테이너를 격리 시킬수있는 이유는 C Group과 네임스페이스를 이용해서이다.

- 하지만 생각해보면 Cgroup과 네임스페이스는 리눅스 환경에서 사용되어지는 것인데..

- docker version (내부적으로 리눅스)

- 왜? 프로그램 -> 리눅스커널 -> 리눅스VM -> 맥OS/윈도우OS->하드웨어


## 2. 기본적인 도커 클라이언트 명령어 알아보기


## 2.1 도커 이미지 내부 파일 구조보기

- 작동순서

1. 도커 클라이언트에 명령어 입력후 도커 서버로 보냄

2. 도커 서버에서 컨테이너를 위한 이미지가 이미 캐쉬가 되어 있는지 확인

3. 없으면 도커 허브에서 다운 받아옴 있다면 그 이미 가지고 있는 이미지 컨테이너 생성

- 이미로 컨테이너 생성하는 순서 복습

1. 먼저 파일 스냅샷되어있는것을 컨테이너의 하드디스크 부분에 올린다.

2. 시작 커맨드를 이용하여 어플리케이션을 실행한다.

- docker run alpine ls 

## 2.1 컨테이너들 나열하기

- docker ps //켜져있는거 보기

- docker run alpine ping localhost

- docker ps -a// 꺼져있는거 까지 모두 보기


## 2.2 도커 컨테이너의 생명주기

- 생성(craete) - 시작(start) - 실행(running) - 중지(stopping) - 삭제(remove)

- docker create <이미지 이름>

- docker start <컨테이너 아이디/이름>

- docker run <이미지이름>

- docker stop <중지할 컨테이너 아이디 /이름>

- docker rm <삭제할 컨테이너 아이디/ 이름>


## 2.3 Docker stop vs docker kill

- 공통점은 둘다 실행중인 컨테이너를 중지

- stop은 Gracefully하게 중지를 시킵니다. 자비롭게 그동안 하던 작업들 완료하고 컨테이너를 중지시킴

- kill 같은경우는 stop과 달리 어떠한것도 기다리지않고 바로 컨테이너를 중지시킴

- docker ps -a// 꺼져있는거 까지 모두 보기

- docker stop(kill) 컨테이너아이디 

## 2.4 컨테이너 삭제하기

- docker rm <아이디 /이름>

- 모든 컨테이너를 삭제하고 싶다면??  docker rm 'docker ps -a -q'

- 이미지를 삭제하고 싶다면?? docker rmi <이미지 id>

- 한번에 컨테이너, 이미지, 네트워크 모두 삭제하고 싶다면? docker system prune

- 도커를 쓰지않을떄 모두 정리하고 싶을 때 사용해주면 좋음

- 하지만, 이것도 실행중인 컨테이너에는 영향을 주지않음

## 2.5 실행중인 컨테이너에 명령어 전달

- 이미실행중인 컨테이너에 명령어를 전달하고 싶다면 ? docker exec <컨테이너 아이디>

- docker ps

- docker exec <컨테이너id> ls

## 2.6 레디스를 이용한 컨테이너 이해

- 레디스 서버가 먼저 작동하고 있어야함

- 그후 레디스 클라이언트를 실행후 명령어를 레디스 서버에 전달

- 레디스 클라이언트 redis-cli -> 명령어 set value1 hello ->레디스 서버 docker run redis


1. 먼저 레디스 서버 작동 -docker run redis

2. 그후 레디스 클라이언트를 켜야야함- 두번째 터미널을 켜서 레디스 클라이언트를 작동 - redis-cli

3. 하지만 에러가 남, 무엇이 잘못되었을까?

4. 답 : 레디스 클라이언트도 컨테이너 안에서 실행시켜야함 - docker exec -it <컨테이너id> redis-cli


## 2.7 실행중인 컨테이너에서 터미널 생활 즐기기

- 컨테이너 쉘 환경으로 접근하기

1.  docker run alpine ping localhost

2.  docker ps (id 보기)

3.  다른 창켜서 docker exec -it 컨테이너아이디 sh

- 터미널에서 나오려면 ctrl+d로 종료해서 나와야함

## 3. 직접 도커 이미지를 만들어 보기

## 3.1 도커 이미지 생성하는 순서

- 복습

1. 도커이미지는 컨테이너를 만들기 위해서 필요한 설정이나 종속성들을 갖고 있는 소프트웨어 패키지입니다.

2. 지금까지 해왔듯이 도커이미지는 dockerhub에 이미 다른 ㅅ람들이 만들어놓은것을 이용할 수 있으며, 직접도커이미지를 만들어 사용할수 있고 직접 만든것을 Dockerhub에 업로드 할수 있습니다.

- 도커 이미지를 이용하여 도커 컨테이너를 생성

- docker create <이미지 이름>

- 그럼 도커이미지는 어떻게 생성 할까요?

- 도커 이미지 생성하는 순서

- Dockerfile 생성 -> 도커클라이언트 ->도커 서버 -> 이미지 생성


## 3.2 Dockerfile 만들기

- Dockerfile : 도커이미지를 만들기위한 설정파일, 어떠한행동해야하는지 설정을 정의해줌

- 도커파일을 만드는 순서(도커 이미가 필요한 것이 무엇인지 생각)

1. 베이스 이미지를 명시해준다(파일 스냅샷에 해당)

2. 추가적으로 필요한 파일을 다운받기 위한 몇가지 명령어를 명시해준다.

3. 컨테이너 시작시 실행될 명령어를 명시해준다(시작시 실행될 명령어에 해당)

- 베이스 이미지는 무엇인가?

 - 도커이미지는 여러개의 레이어로 되어있다. 이미지의 기반이 되는 부분

- 이미지 - 베이스이미지 (OS) - 레이어 - 레이어

- 이번강좌는 hello라는 문구

``` dockerfile
# 베이스 이미지를 명시, 태그를 붙이지 않으면 최근버전으로 받음
FROM baseIamge

# 추가적으로 필요한 파일들을 다운로드 받는다.
RUN command

# 컨테이너 시작 실행될 명령어(실행파일 및 쉘 스크립트) 를 명시해준다.
CMD [ "exccutable" ]

```


```  dockerfile
# 베이스 이미지를 명시, 태그를 붙이지 않으면 최근버전으로 받음
FROM alpine

# 추가적으로 필요한 파일들을 다운로드 받는다.
#RUN command

# 컨테이너 시작 실행될 명령어(실행파일 및 쉘 스크립트) 를 명시해준다.
CMD [ "echo", "hello" ]


```

## 3.3 도커 파일로 도커 이미지 만들기

- Dockerfile 생성 -> 도커클라이언트 ->도커 서버 -> 이미지 생성

- docker bulid ./ 또는 docker build .

- docker run -it <도커id>

## 3.4 내가 만든 이미지 기억하기 쉬운 이름 주기

- 이름 쉽게 짓기

- docker build -t smile/hello:latest ./

- -t 나의도커아이디 / 저장소 프로젝트 이름 : 버전


## 4. 도커를 이용한 간단한 Node.js 어플 만들기

## 4.1 섹션 설명

- Node.js가 중요하지않고 도커환경에 어떻게 띄우는 지 확인

## 4.2 Node.js 앱만들기

- package.json 만들기

``` json
{
  "name": "nodejs-docker-app",
  "version": "1.0.0",
  "description": "",
  "main": "server.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "dependencies": {
    "express":"4.17.1",
    "nodemon":"2.0.4"
  },
  "author": "",
  "license": "ISC"
}


```

- 간단한 node.js 만들기

``` js
const express = require('express');

const PORT = 8080;

//APP 
const app = express();
app.get('/', (req,res) => {
    res.send("반가워요!!!!!!!")
});

app.listen(PORT);
console.log("Server is running")
```


## 4.3 Dockerfile 작성하기

``` dockerfile
FROM node:10

RUN npm install

CMD ["nodemon", "server.js"]
```

- 에러 발생

1. npm가 실행이안되서 안됨 -> RUN 부분 추가

2. npm install에서 에러 -> COPY 부분 추가


## 4.4 Package.json 파일이 없다고 나오는 이유

- Node 베이스 이미지 ->생성 -> 임시 컨테이너

``` dockerfile
FROM node:10

WORKDIR /usr/src/app

COPY package.json ./

RUN npm install

COPY ./ ./

CMD ["nodemon", "server.js"]
```

