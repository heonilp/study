# 2021년도 interview 준비



## select랑 order by랑 어떤게 먼저 실행될까요?

from /select/ group by /having /select /order by
순서
select ~ // 조회할 컬럼  *필수 실행순서 : 5
from ~ // 조회대상 테이블  *필수 실행순서 : 1
where ~ // 조회할 행을 제한 실행순서 : 2
group by ~ // 조회된 행을 그룹핑 실행순서 : 3
having ~ // 그룹함수를 사용해서 행을 제한 실행순서 : 4
order by ~ // 조회된 행을 정렬 실행순서 : 6

1. 테이블을 선택한다.
2. 테이블의 행에서 조건을 만족하는 행만 선택한다.
3. 선택된 행을 그룹핑한다.
4. 그룹핑된 행에 그룹함수를 사용해서 행을 제한한다.
5. 그룹핑된 행에 그룹함수를 적용한다.
6. 정렬한다.


## DMA : Direct Memory Access, DMA
직접 메모리 접근(Direct Memory Access, DMA)은 특정 하드웨어 하위 시스템이
CPU와 독립적으로 메인 시스템 메모리에 접근할 수 있게 해주는 컴퓨터 시스템의 기능이다.

## 트리 트리구성조건 복잡도
트리는 일반적으로 대상 정보의 각 항목들을 계층적으로 연관되도록 구조화시키고자 할 때 사용하는 비선형 자료구조이다

이진트리(Binary Tree)
이진트리는 트리를 구성하는 노드들의 최대 차수(degree)가 2인 노드들로 구성되는 트리이다.
루트 노드(root node): 부모가 없는 노드, 트리는 하나의 루트 노드만을 가진다.
단말 노드(leaf node): 자식이 없는 노드, ‘말단 노드’ 또는 ‘잎 노드’라고도 부른다.
내부(internal) 노드: 단말 노드가 아닌 노드
간선(edge): 노드를 연결하는 선 (link, branch 라고도 부름)
형제(sibling): 같은 부모를 가지는 노드
노드의 크기(size): 자신을 포함한 모든 자손 노드의 개수
노드의 깊이(depth): 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수
노드의 레벨(level): 트리의 특정 깊이를 가지는 노드의 집합
노드의 차수(degree): 하위 트리 개수 / 간선 수 (degree) = 각 노드가 지닌 가지의 수
트리의 차수(degree of tree): 트리의 최대 차수
트리의 높이(height): 루트 노드에서 가장 깊숙히 있는 노드의 깊이

종 연산의 시간복잡도는 O(h)이다.
최악의 경우 트리의 높이 h는 O(n)이다.
실제 위에서 학습한 BST의 Search, Insert, Delete 모두 최악의 경우 시간복잡도는 O(n)이다.
그러나, 이것은 실제 최악의 경우에 해당한다. BST에 데이터들이 random하게 구성된다고 가정했을때, 
평균 트리의 높이는 O(logn)이 된다. 이는 Search, Insert, Delete 연산의 시간복잡도가 O(logn)이 된다는 이야기이다.
최악의 경우에도 O(logn)을 넘지 않도록 하는 균형잡힌 트리
레드-블랙 트리 등
키의 삽입이나 삭제시 추가로 트리의 균형을 잡아줌으로써 높이를 O(logn)으로 유지한다
Heap
힙(heap)은 완전이진트리(Complete binary tree) 를 기본으로 한 자료구조(tree-based structure) (시간복잡도 : O(log N))

## 동기 비동기 차이

동기는 요청과 그 결과가 동시에 일어난다는 뜻이며,
다시 말하면, 어떤 객체 또는 함수 내부에서 다른 함수를 호출했을 때 이 함수의 결과를 호출한 쪽에서 처리하면 동기입니다.

비동기는 요청과 그 결과가 동시에 일어나지 않는다는 뜻이며,
동기와 달리 어떤 객체 또는 함수 내부에서 다른 함수를 호출했을 때 이 함수의 결과를 호출한 쪽에서 처리하지 않으면 비동기입니다.

Synchronous 에서는 System Call이 끝날때까지 기다리고 결과물을 가져온다.
Asynchronous 에서는 System Call이 완료되지 않아도 나중에 완료가 되면 그때 결과물을 가져온다.
주로 Callback 함수를 통해 결과물을 가져온다.
Synchronous Vs Asynchronous 차이점
가장 큰 차이점은 결과물을 가저오는 시점이 다르다.

## 데드락 설명
- 상호배제  , 점유대기, 비선점 , 순환대기 

## 샤딩 및 샤딩 분할방법

##  OSI 7계층 -  TCP4, IP3

##  DB 1,2,3정규화
제1차 정규화
제1차 정규화는 같은 성격과 내용의 컬럼이 연속적으로 나타나는 컬럼이 존재할 때, 해당 컬럼을 제거하고 기본테이블의 PK를 추가해 새로운 테이블을 생성하고, 기존의 테이블과 1:N 관계를 형성하는 것이다.
제2차 정규화
제2정규화는 PK가 여러 키로 구성된 복합키(Composite Primary Key)로 구성된 경우가 2차 정규화의 대상이 되며, 복합키 전체에 의존하지 않고 복합키의 일부분에만 종속되는 속성들이 존재할 경우 (즉, 부분적 함수 종속 관계) 이를 분리하는 것이다.
제3차 정규화
테이블의 키가 아닌 컬럼들은 기본키에 의존해야 하는데 겉으로는 그런 것처럼 보이지만 실제로는 기본키가 아닌 다른 일반 컬럼에 의존하는 컬럼들이 있을 수 있다. 이를 (이전적 함수 종속 관계)라고 한다. 제 3정규화는 PK에 의존하지 않고 일반컬럼에 의존하는 컬럼들을 분리한다.


## 쿠키 세션

## mvc패턴

## post get차이

## 가상함수, 가상함수 테이블
가상함수를 사용하면 같은 타입으로 선언된 객체 포인터 변수라도 가리키고 있는 객체에 따라 오버라이딩 된 함수를 호출하는 것을 위에서 확인했다. 
컴파일 시 가상함수가 정의된 클래스가 있다면 가상함수테이블(Virtual function table)이 만들어져서 바이너리 'rdata'영역에 기록되며 해당 클래스로 만들어진 
객체에서 함수를 호출할 때 해당 클래스의 가상함수 테이블을 참조해서 함수를 호출된다. 편의를 위해 가상함수테이블은 "vtable" 이라고 명칭한다. 포인터 멤버변수 vptr

자식 클래스의 vtable은 부모 클래스의 vtable 값이 그대로 복사되며, 오버라이딩 된 함수만 주소가 새로 업데이트 된다고 한다. 
그리고 만약 자식 클래스에 부모에 없는 새로운 가상함수를 추가할 경우, 객체의 vtable 마지막 부분에 추가된다.

가상함수 테이블을 보면, key와 value가 있다.
key에는 호출하고자 하는 함수를 구분 지어주는 식별자이고,
value는 구분자에 해당하는 함수의 주소이다.

## java 제네릭과 C++ 템플릿차이
Java Generic type과 C++ Template는 생긴 것은 비슷하지만 두 언어가 이를 처리하는 과정은 다르다.
Java의 Generic은 타입 제거라는 개념에 근거한다. 이 기법은 소스코드를 Java 가상 머신(JVM)이 인식하는 바이트 코드로 변환할 때 인자로 주어진 타입을 제거하는 기술이다
. Java Generic이 있다고 해서 크게 달라지기보다 뭔가 더 예쁘게 작성할 수 있게 해 준다. 따라서 이를 문법적 양념(syntactic sugar)라고 부른다.
C++의 template은 좀 더 우아한 형태의 매크로로써 상황이 다르다. 컴파일러는 인자로 주어진 각각의 타입에 대해 별도의 템플릿 코드를 생성한다. 
(ex. Myclass<Foo>, Myclass<Bar>가 서로 static 변수를 공유하지 않는다.) 반면에 Java static 변수는 Myclass로 만든 모든 객체가 공유한다.
이러한 구조적인 차이 때문에 Java Generic과 C++ template에는 차이점이 다수 있다.
- C++ Template에는 int와 같은 기본 타입을 인자로 넘길 수 있다. Java Generic에서는 불가능하다. 모든 타입은 Object를 상속해야 하며 따라서 int 대신 Integer를 사용해야 한다
- Java의 경우, Generic 타입 인자를 특정한 타입이 되도록 제한할 수 있다. 가령 CardDeck을 Generic 클래스로 정의할 때, 그 인자로는 CardGame의 하위 클래스만 사용되도록 제한하는 것이 가능하다. (한정적 형인자
- C++ Template은 인자로 주어진 타입으로부터 객체를 만들어 낼 수 있다. Java에서는 불가능하다.
- Java에서 Generic type 인자는 static 메서드나 변수를 선언하는 데 사용될 수 없다. MyClass<Foo>와 MyClass<Bar>가 공히 이 메서드와 변수를 공유할 것이기 때문이다. 
C++에서는 이 두 클래스는 다른 클래스이므로 템플릿 타입 인자를 static 메서드나 변수를 선언하는 데 사용할 수 있다.
- Java에서 MyClass로 만든 모든 객체는 제네릭 타입 인자가 무엇이냐에 관계없이 전부 동등한 타입이다. 실행시간에 타입 인자 정보는 삭제된다. 
C++에서는 다른 템플릿 타입 인자를 사용해 만든 객체는 서로 다른 타입의 객체이다.


소트

## 스마트포인터
new delete 짝이 안맞으면 발생하는일- 메모리누수 발생

## 메모리릭 프로그램 - valgrind, LeakDiag , Leak Detector, Mem Reduct

##  stl 벡터 resize연산 내부 동작
reserve()는 공간이 예약된다.
배열을 만들때 int array[크기] 하는것과 같다.
만약 앞으로 데이터가 자주 추가된다면 벡터가 가득 찼을때 스스로 공간을 늘리지 않기 때문에 성능을 더 향상할 수 있다.
만약 전부 찬상태에서 또 집어넣으면 늘어난다.
resize()는 공간 예약 + 안의 모든 공간을 특정한 값으로 채운다.
변수를 만들때 쓰레기값이 없게 하기위해 NULL로 초기화 하는것과 비슷하다. ex) int array[10] = {0 ,}
현재보다 큰 공간을 예약하면 그만큼 더 집어넣는다. ex) 5개가 들어있는 상태에서 resize(10)하면 5개가 더들어감 -> 5 + 5 = 10
용량이 딱 정해져 있다. 더들어 오게 된다면 버려지게 된다.

## 확률에 대한 지식(랜덤 지식, 모던)
``` C++
#include <random>
#include <iostream> 
int main() {
std::mt19937 mtRand;
for(int i = 0; i < 10; i++) 
{
 std::cout << mtRand() << std::endl;
}
```

## 메모리구조

## 절차지향과 객체지향의차이

## 프로세스와 스레드 차이

## pcb설명

## 메모리단편화

## 메모리 파편화 문제 해결 방법

1. 페이징(Paging)기법 - 가상메모리사용, 외부 단편화 해결, 내부 단편화 존재
보조기억장치를 이용한 가상메모리를 같은 크기의 블록으로 나눈 것을 페이지라고 하고 RAM을 페이지와 같은 크기로 나눈 것을 프레임이라고 할 때,
페이징 기법이란 사용하지 않는 프레임을 페이지에 옮기고, 필요한 메모리를 페이지 단위로 프레임에 옮기는 기법.
페이지와 프레임을 대응시키기 위해 page mapping과정이 필요해서 paging table을 만든다.


2. 세그멘테이션(Segmentation)기법 - 가상메모리사용, 내부 단편화 해결, 외부 단편화 존재
페이징기법에서 가상메모리를 같은 크기의 단위로 분할했지만 세그멘테이션기법에서는 가상메모리를 서로 크기가 
다른 논리적 단위인 세그먼트로 분할해서 메모리를 할당하여 실제 메모리 주소로 변환을 하게 된다.
각 세그먼트는 연속적인 공간에 저장되어 있다.
세그먼트들의 크기가 다르기 때문에 미리 분할해 둘 수 없고 메모리에 적재될 때 빈 공간을 찾아 할당하는 기법이다.
마찬가지로 mapping을 위해 세그먼트 테이블이 필요하다.

## C++ list 소트와 sort차이

## C++ 이동 시맨틱
1. 이동 시맨틱은 이동 생성자, 이동 대입 연산자를 통해 지원함.
이동 생성자, 이동 대입 연산자는 원본 객체 --> 새로운 객체로 복사 --> 원본 null로 초기화 의 과정이다.
즉 객체에 대한 메모리 소유권을 이동함. 그 결과 댕글링 포인터나, 메모리 릭 발생을 예방함.
2. 이동 시맨틱은 r-value 참조로 구현됨. 
내가 어떤 클래스를 구현했고, 그 클래스가 이동 시맨틱으로 동작하게 하려면 위에서 언급한 
 
3. 왜 사용 하는가? 
불필요한 복사를 하지 않아서. 메모리 할당의 횟수를 줄일 수 있다.

4. 어떤 상황에서 사용하는가?
첫번째 컨테이너에 담을 때
가령 벡터에 객체를 담을때 벡터는 동적으로 확장을 하는데, 객체에 이동 시맨틱을 정의 및 구현하면 
확장시 복제 대신 이동이 일어나서 불필요한 복사를 방지한다. 이게 몇번 안하면 상관 없을수도 있으나
수천번 수만번을 한다면 분명 큰 오버헤드이다.
두번째 임시 객체를 리턴할 때, 임시 객체는 함수 리턴후에 소멸하는데, 일반 복제 대입 연산 대신 이동 대입 연산을
호출한다.

## shared_ptr 내부 동작원리

## weak_ptr,  일반 c 포인터차이점

## 스택 2개로 큐구현

## 퀵소트 설명
퀵 정렬은 기준점(pivot)을 정하고 앞(left)와 뒤(right)를 비교하면서 정렬을 하는 알고리즘입니다.

과정
리스트에서 임의의 원소를 고릅니다. 그것을 pivot이라 합니다. (일반적으로 가운데 원소를 고릅니다.)
pivot의 앞에는 pivot 보다 작은 원소들로, pivot의 뒤에는 pivot 보다 큰 원소들이 오도록 교환해 줍니다. (divided)
divided 된 두 개의 작은 리스트에 대해 Recursive 하게 위의 과정을 반복합니다.
Recursive의 종료조건은 리스트의 크기가 0 입니다.
장점: 수행속도가 빠른 정렬 알고리즘이다.

단점: 중심값이 같을 경우에는 배열의 순서가 파괴 될 수도 있으며 안정성이 없다는 점이다.

멀티스레딩 혹은 멀티프로세스할때 스케줄링 기법 FCFS SJF 라운드로빈, 멜티레벨큐

--------------------------------------------------------------


##  데드락 4가지조건
데드락 : 교착상태 , 한정적 자원을 사용할떄 걸림

상점비순

상호배제 :한자원에 대해서 여러프로세스 접근 불가
점유대기 : 자원을 가지고 있는 상태에서 다른 자원을 기다림
비선점 : 사용을 끝날떄까지 자원을 뻇을수 없다
순환대기 : 순환적으로 다음 프로세스가 요구하는 자원을 가지고있다.
