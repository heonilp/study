# CS 공부, 면접 대비
- 자주 나오는 개념위주로 정리

## 1. 네트워크

### OSI 7계층
* OSI(Open Systems Interconnection Reference Model)란
    * 국제표준화기구(ISO)에서 개발한 모델로, 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명한 것이다.
    * 이 모델은 프로토콜을 기능별로 나눈 것이다. 
    * 각 계층은 하위 계층의 기능만을 이용하고, 상위 계층에게 기능을 제공한다. 
    * '프로토콜 스택' 혹은 '스택'은 이러한 계층들로 구성되는 프로토콜 시스템이 구현된 시스템을 가리키는데, 프로토콜 스택은 하드웨어나 소프트웨어 혹은 둘의 혼합으로 구현될 수 있다. 
    * 일반적으로 하위 계층들은 하드웨어로, 상위 계층들은 소프트웨어로 구현된다.
1. 물리 계층(Physical layer)
    * 네트워크의 기본 네트워크 하드웨어 전송 기술을 이룬다. 
    * 네트워크의 높은 수준의 기능의 논리 데이터 구조를 기초로 하는 필수 계층이다.
    * 전송 단위는 Bit이다.
2. 데이터 링크 계층(Data link layer)
    * 포인트 투 포인트(Point to Point) 간 신뢰성있는 전송을 보장하기 위한 계층으로 CRC 기반의 오류 제어와 흐름 제어가 필요하다. 
    * 주소 값은 물리적으로 할당 받는데, 이는 네트워크 카드가 만들어질 때부터 맥 주소(MAC address)가 정해져 있다는 뜻이다. 
    * 데이터 링크 계층의 가장 잘 알려진 예는 이더넷이다.
    * 데이터 전송 단위는 Frame이다. 
3. 네트워크 계층(Network layer)
    * 여러개의 노드를 거칠때마다 경로를 찾아주는 역할을 하는 계층으로 다양한 길이의 데이터를 네트워크들을 통해 전달하고, 그 과정에서 전송 계층이 요구하는 서비스 품질(QoS)을 제공하기 위한 기능적, 절차적 수단을 제공한다. 
    * 네트워크 계층은 라우팅, 흐름 제어, 세그멘테이션(segmentation/desegmentation), 오류 제어, 인터네트워킹(Internetworking) 등을 수행한다. 
    * 논리적인 주소 구조(IP), 곧 네트워크 관리자가 직접 주소를 할당하는 구조를 가지며, 계층적(hierarchical)이다.
    * 데이터 전송 단위는 Datagram(Packet)이다.
4. 전송 계층(Transport layer)
    * 양 끝단(End to end)의 사용자들이 신뢰성있는 데이터를 주고 받을 수 있도록 해 주어, 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해준다. 
    * 시퀀스 넘버 기반의 오류 제어 방식을 사용한다. 
    * 전송 계층은 특정 연결의 유효성을 제어하고, 일부 프로토콜은 상태 개념이 있고(stateful), 연결 기반(connection oriented)이다. (이는 전송 계층이 패킷들의 전송이 유효한지 확인하고 전송 실패한 패킷들을 다시 전송한다는 것을 뜻한다.) 
    * 가장 잘 알려진 전송 계층의 예는 TCP이다.
    * 데이터 전송 단위는 Segment이다.
5. 세션 계층(Session layer)
    * 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공한다. 
    * 동시 송수신 방식(duplex), 반이중 방식(half-duplex), 전이중 방식(Full Duplex)의 통신과 함께, 체크 포인팅과 유휴, 종료, 다시 시작 과정 등을 수행한다. 
    * 이 계층은 TCP/IP 세션을 만들고 없애는 책임을 진다.
6. 표현 계층(Presentation layer)
    * 코드 간의 번역을 담당하여 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어 준다. 
    * MIME 인코딩이나 암호화 등의 동작이 이 계층에서 이루어진다. 
7. 응용 계층(Application layer)
    * 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다. 
    * 일반적인 응용 서비스는 관련된 응용 프로세스들 사이의 전환을 제공한다. 

### TCP VS UDP

* 네트워크 계층 중 **전송 계층에서 사용하는 프로토콜**
* TCP(Transmission Control Protocol)  
    * 인터넷 상에서 데이터를 메세지의 형태(**세그먼트** 라는 블록 단위)로 보내기 위해 IP와 함께 사용하는 프로토콜이다.
    * TCP와 IP를 함께 사용하는데, IP가 데이터의 배달을 처리한다면 TCP는 패킷을 추적 및 관리한다.
    * **연결형 서비스로** 가상 회선 방식을 제공한다.
        * 3-way handshaking과정을 통해 연결을 설정하고, 4-way handshaking을 통해 연결을 해제한다.
    * 흐름제어 및 혼잡제어를 제공한다.
        * 흐름제어
            * 데이터를 송신하는 곳과 수신하는 곳의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지하는 것
            * 송신하는 곳에서 감당이 안되게 많은 데이터를 빠르게 보내 수신하는 곳에서 문제가 일어나는 것을 막는다.
        * 혼잡제어
            * 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것
            * 정보의 소통량이 과다하면 패킷을 조금만 전송하여 혼잡 붕괴 현상이 일어나는 것을 막는다.
    * 높은 신뢰성을 보장한다.
    * UDP보다 속도가 느리다.
    * 전이중(Full-Duplex), 점대점(Point to Point) 방식이다.
        * 전이중
            * 전송이 양방향으로 동시에 일어날 수 있다.
        * 점대점
            * 각 연결이 정확히 2개의 종단점을 가지고 있다.
        * 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.
    * 연속성보다 신뢰성있는 전송이 중요할 때에 사용된다.

* UDP(User Datagram Protocol)  
    * 데이터를 **데이터그램** 단위로 처리하는 프로토콜이다.
    * **비연결형 서비스로** 데이터그램 방식을 제공한다.
        * 연결을 위해 할당되는 논리적인 경로가 없다.
        * 그렇기 때문에 각각의 패킷은 다른 경로로 전송되고, 각각의 패킷은 독립적인 관계를 지니게 된다.
        * 이렇게 데이터를 서로 다른 경로로 독립적으로 처리한다.
    * 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.
    * UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.
    * 신뢰성이 낮다.
    * TCP보다 속도가 빠르다.
    * 신뢰성보다는 연속성이 중요한 서비스, 예를 들면 실시간 서비스(streaming)에 사용된다.

* 참고
  * UDP와 TCP는 각각 별도의 포트 주소 공간을 관리하므로 같은 포트 번호를 사용해도 무방하다. 즉, 두 프로토콜에서 동일한 포트 번호를 할당해도 서로 다른 포트로 간주한다.
  * 또한 같은 모듈(UDP or TCP) 내에서도 클라이언트 프로그램에서 동시에 여러 커넥션을 확립한 경우에는 서로 다른 포트 번호를 동적으로 할당한다. (동적할당에 사용되는 포트번호는 49,152~65,535이다.)

### TCP 연결과정, 해제과정
- TCP 3 way handshake & 4 way handshake

* TCP는 장치들 사이에 논리적인 접속을 성립(establish)하기 위하여 연결을 설정하여 **신뢰성을 보장하는 연결형 서비스** 이다.
* 3-way handshake 란
  * TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 **연결을 설정(Connection Establish)** 하는 과정
  * 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작하기 전에 한 쪽이 다른 쪽이 준비되었다는 것을 알 수 있도록 한다.
  * 즉, TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.
      * A 프로세스(Client)가 B 프로세스(Server)에 연결을 요청
        1. A -> B: SYN
            * 접속 요청 프로세스 A가 연결 요청 메시지 전송 (SYN)
            * 송신자가 최초로 데이터를 전송할 때 Sequence Number를 임의의 랜덤 숫자로 지정하고, SYN 플래그 비트를 1로 설정한 세그먼트를 전송한다.
            * PORT 상태 - B: LISTEN, A: CLOSED
        2. B -> A: SYN + ACK
            * 접속 요청을 받은 프로세스 B가 요청을 수락했으며, 접속 요청 프로세스인 A도 포트를 열어 달라는 메시지 전송 (SYN + ACK)
            * 수신자는 Acknowledgement Number 필드를 (Sequence Number + 1)로 지정하고, SYN과 ACK 플래그 비트를 1로 설정한 세그먼트를 전송한다.
            * PORT 상태 - B: SYN_RCV, A: CLOSED
        3. A -> B: ACK
            * PORT 상태 - B: SYN_RCV, A: ESTABLISHED
            * 마지막으로 접속 요청 프로세스 A가 수락 확인을 보내 연결을 맺음 (ACK)
            * 이때, 전송할 데이터가 있으면 이 단계에서 데이터를 전송할 수 있다.
            * PORT 상태 - B: ESTABLISHED, A: ESTABLISHED
* 4-way handshake 란
  * TCP의 **연결을 해제(Connection Termination)** 하는 과정
      * A 프로세스(Client)가 B 프로세스(Server)에 연결 해제를 요청
        1. A -> B: FIN
            * 프로세스 A가 연결을 종료하겠다는 FIN 플래그를 전송
            * 프로세스 B가 FIN 플래그로 응답하기 전까지 연결을 계속 유지
        2. B -> A: ACK
            * 프로세스 B는 일단 확인 메시지를 보내고 자신의 통신이 끝날 때까지 기다린다. (이 상태가 TIME_WAIT 상태)
            * 수신자는 Acknowledgement Number 필드를 (Sequence Number + 1)로 지정하고, ACK 플래그 비트를 1로 설정한 세그먼트를 전송한다.
            * 그리고 자신이 전송할 데이터가 남아있다면 이어서 계속 전송한다.
        3. B -> A: FIN
            * 프로세스 B가 통신이 끝났으면 연결 종료 요청에 합의한다는 의미로 프로세스 A에게 FIN 플래그를 전송
        4. A -> B: ACK
            * 프로세스 A는 확인했다는 메시지를 전송

* 참고 - ***포트(PORT) 상태 정보***
  * CLOSED: 포트가 닫힌 상태
  * LISTEN: 포트가 열린 상태로 연결 요청 대기 중
  * SYN_RCV: SYNC 요청을 받고 상대방의 응답을 기다리는 중

  * ESTABLISHED: 포트 연결 상태
* 참고 - ***플래그 정보***
  * TCP Header에는 CONTROL BIT(플래그 비트, 6bit)가 존재하며, 각각의 bit는 "URG-ACK-PSH-RST-SYN-FIN"의 의미를 가진다.
    * 즉, 해당 위치의 bit가 1이면 해당 패킷이 어떠한 내용을 담고 있는 패킷인지를 나타낸다.
  * SYN(Synchronize Sequence Number) / 000010
    * 연결 설정. Sequence Number를 랜덤으로 설정하여 세션을 연결하는 데 사용하며, 초기에 Sequence Number를 전송한다.
  * ACK(Acknowledgement) / 010000
    * 응답 확인. 패킷을 받았다는 것을 의미한다.
    * Acknowledgement Number 필드가 유효한지를 나타낸다.
    * 양단 프로세스가 쉬지 않고 데이터를 전송한다고 가정하면 최초 연결 설정 과정에서 전송되는 첫 번째 세그먼트를 제외한 모든 세그먼트의 ACK 비트는 1로 지정된다고 생각할 수 있다.
  * FIN(Finish) / 000001
    * 연결 해제. 세션 연결을 종료시킬 때 사용되며, 더 이상 전송할 데이터가 없음을 의미한다.

#### :question:TCP 관련 질문 1
* Q. TCP의 연결 설정 과정(3단계)과 연결 종료 과정(4단계)이 단계가 차이나는 이유?
  * A. Client가 데이터 전송을 마쳤다고 하더라도 Server는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 FIN에 대한 ACK만 보내고, 데이터를 모두 전송한 후에 자신도 FIN 메시지를 보내기 때문이다.


#### :question:TCP 관련 질문 2
* Q. 만약 Server에서 FIN 플래그를 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황이 발생하면 어떻게 될까?
  * A. 이러한 현상에 대비하여 Client는 Server로부터 FIN 플래그를 수신하더라도 일정시간(Default: 240sec)동안 세션을 남겨 놓고 잉여 패킷을 기다리는 과정을 거친다. (TIME_WAIT 과정)


#### :question:TCP 관련 질문 3
* Q. 초기 Sequence Number인 ISN을 0부터 시작하지 않고 난수를 생성해서 설정하는 이유?
  * A. Connection을 맺을 때 사용하는 포트(Port)는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용된다. 따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재한다. 서버 측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순처적인 Number가 전송된다면 이전의 Connection으로부터 오는 패킷으로 인식할 수 있다. 이런 문제가 발생할 가능성을 줄이기 위해서 난수로 ISN을 설정한다.


### HTTP 1.1 vs 2.0, HTTP 3.0 QUIC

HTTP 1.1 vs 2.0

- [참조](https://ijbgo.tistory.com/26)

- TTP/1.1 동작 방식
HTTP/1.1는 기본적으로 Connection당 하나의 요청을 처리 하도록 설계
동시 전송이 불가능하고 요청과 응답이 순차적으로 이뤄짐
HTTP 문서 안에 포함된 다수의 리소스 (Images, CSS, Script)를 처리하려면 요청할 리소스 개수에 비례해서 Latency(대기 시간)는 길어짐

- HTTP/1.1 단점
1. HOL (Head Of Line) Blocking - 특정 응답의 지연
HTTP의 HOL Blocking
TCP의 HOL Blocking
- HTTP/1.1의 connection당 하나의 요청 처리를 개선할 수 있는 기법 중 pipelining이 존재 
- Connection을 통해서 다수개의 파일을 요청/응답 받을 수 있는 기법

2.  RTT( Round Trip Time ) 증가
일반적으로 하나의 connection에 하나의 요청을 처리
그렇기 때문에 매 요청별로 connection을 만들게 되고 TCP상에서 동작하는 HTTP의 특성상 3-way Handshake 가 반복적으로 일어나고
또한 불필요한 RTT증가와 네트워크 지연을 초래하여 성능을 저하 시킴

3.  무거운 Header 구조
http/1.1의 헤더에는 많은 메타정보들을 저장
매 요청 시 마다 중복된 Header 값을 전송하게 되며(별도의 domain sharding을 하지 않았을 경우) 
또한 해당 domain에 설정된 cookie 정보도 매 요청 시 마다 헤더에 포함되어 전송
전송하려는 값보다 헤더 값이 더 큰 경우도 자주 발생

- HTTP/2 등장
HTTP가 유선 상에서 표현 방법을 대치 하는 것

**성능에 초점**
최종 사용자가 대기 시간, 네트워크 및 서버 리소스 사용을 인식
하나는 브라우저에서 웹 사이트로의 단일 연결을 허용하는 것

1. Multiplexed Streams
한 커넥션으로 동시에 여러 개의 메세지를 주고 받을 있으며, 응답은 순서에 상관없이 stream으로 주고 받음
HTTP/1.1의 Connection Keep-Alive, Pipelining의 개선

2. Stream Prioritization (스트림 우선순위)
클라이언트가 요청한 HTML문서 안에 CSS파일 1개와 Image파일 2개가 존재하고 
이를 클라이언트가 각각 요청하고 난 후 Image파일보다 CSS파일의 수신이 늦어지는 경우 브라우저의 
렌더링이 늦어지는 문제가 발생하는데 HTTP/2의 경우 리소스간 의존관계(우선순위)를 설정하여 이런 문제를 해결

3. Server Push
서버는 클라이언트의 요청에 대해 요청하지도 않은 리소스를 보내줄 수 있음
클라이언트(브라우저)가 HTML문서를 요청하고 해당 HTML에 여러 개의 리소스(CSS, Image...) 가 포함되어 
있는 경우 HTTP/1.1에서 클라이언트는 요청한 HTML문서를 수신한 후  HTML문서를 해석하면서 필요한
리소스를 재 요청하는 반면 HTTP/2에서는 Server Push기법을 통해서 클라이언트가 요청하지 않은
(HTML문서에 포함된 리소스) 리소스를 Push 해주는 방법으로 클라이언트의 요청을 최소화 해서 성능 향상을 이끌어 냄
PUSH_PROMISE 라고 부르며 PUSH_PROMISE를 통해서 서버가 전송한 리소스에 대해선 클라이언트는 요청을 않음

4. Header Compression (헤더 압축)

HTTP/2는 Header 정보를 압축하기 위해 Header Table과 Huffman Encoding 기법을 사용하여 처리하는데
이를 HPACK 압축방식이라 부르며 별도의 명세서(RFC 7531)로 관리.

### HTTP 3.0 (QUIC)

- [참고 1](https://evan-moon.github.io/2019/10/08/what-is-http3/)
- [참고 2](https://ykarma1996.tistory.com/86)

- HTTP/3의 장점을 설명하기 위해서는 기존의 TCP를 포기하고 QUIC를 채택하면서 얻게 된 장점을 설명해야한다.
   즉, UDP 기반의 프로토콜인 QUIC을 사용하여 통신하는 프로토콜이다. HTTP/3와 기존 HTTP 들과 가장 큰 차이점이라면 TCP가 아닌 UDP 기반의 통신을 한다는 것이다.
```
암호화가 프로토콜의 일부기능으로 포함되어 있다
스트림 연결과 암호화 스펙등을 포함한 모든 핸드쉐이크가 단일 요청/응답으로 끝난다
패킷이 개별적으로 암호화 되며, 다른 데이터 부분의 패킷을 기다릴 필요가 없다
통신이 멀티플렉싱 되며 이를 통해 HOLB를 극복할 수 있다
QUIC는 운영체제 커널과 독립적으로 응용 프로그램 공간내에서 구현할 수 있으며, 덕분에 데이터의 이동에 따른 컨텍스트 전환에 의한 오버헤드가 없어진다
Source Address와 무관하게 서버에 대한 연결을 고유하게 식별하는 연결 식별자가 포함되어 있어, IP주소가 변경되더라도 커넥션을 유지할 수 있다
```

- 이러한 QUIC를 이용하는 HTTP/3는 새로운 연결에 대해서 핸드세이크로 인한 지연, 패킷 손실이 다른 스트림에 미치는 영향, 패킷 손실로 인한 지연으로부터 자유로울 수 있다.

- 그런데, 결국 QUIC가 다한거면 QUIC위에 단순히 기존의 HTTP/2를 올리기만 해서 사용하면 되는게 아닌가? HTTP/2도 스트림 멀티플렉싱을 지원한다면서? 다른 수정이 필요해?

결론적으로보면 니 생각보다 복잡하다이다. HTTP/2의 일부 기능들은 QUIC 위에서도 별도의 변환 없이 그대로 적용할 수 있지만, 몇몇 기능들은 그렇지 않다. 대표적으로 예를 들자면, HPACK 이라는 HTTP/2에서 사용하던 헤더 압축 체계는 응답의 전달순서에 따라 크게 좌우되는데, QUIC는 스트림간의 순서를 보장하지 않기 때문에 사용할 수 없다.(이러한 경우 QPACK이라는 새로운 HTTP 헤더 압축체계를 작성했다고 한다.)

- 지금 사용중인가?
빠른 콘텐츠 전달이 생명인 CDN들은앞 다투어 서비스들을 적용하고 있고, 당연히 해당 CDN을 이용하는 서비스 제공자들은 HTTP/3를 지원한다.

구글에서 제공하는 상당수의 컨텐츠들(유튜브 포함), 페이스북 등이 지원하도록 구성되었고, 클라이언트는 크롬, 엣지 브라우저, curl 등이 이미 지원하고 있다.


### HTTPS / SSL 특징, 연결과정

HTTPS / SSL 특징

- HTTP 프로토콜
    - 개념 
        - HyperText Transfer Protocol
        - 웹 상에서 클라이언트와 서버 간에 요청/응답(request/response)으로 정보를 주고 받을 수 있는 프로토콜
    - 특징 
        - 주로 HTML 문서를 주고받는 데에 쓰인다. 
        - TCP와 UDP를 사용하며, **80번 포트**를 사용한다.
        - 1) 비연결(Connectionless)
            - 클라이언트가 요청을 서버에 보내고 서버가 적절한 응답을 클라이언트에 보내면 바로 연결이 끊긴다.
        - 2) 무상태(Stateless)
            - 연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태 정보를 유지하지 않는다.
- HTTPS 프로토콜 
    - 개념 
        - HyperText Transfer Protocol over Secure Socket Layer
            - 또는 HTTP over TLS, HTTP over SSL, HTTP Secure
        - 웹 통신 프로토콜인 HTTP의 보안이 강화된 버전의 프로토콜
    - 특징 
        - HTTPS의 기본 TCP/IP 포트로 **443번 포트**를 사용한다.
        - HTTPS는 소켓 통신에서 일반 텍스트를 이용하는 대신에, 웹 상에서 정보를 암호화하는 SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화한다. 
            - TLS(Transport Layer Security) 프로토콜은 SSL(Secure Socket Layer) 프로토콜에서 발전한 것이다.
            - 두 프로토콜의 주요 목표는 기밀성(사생활 보호), 데이터 무결성, ID 및 디지털 인증서를 사용한 인증을 제공하는 것이다.
        - 따라서 데이터의 적절한 보호를 보장한다. 
            - 보호의 수준은 웹 브라우저에서의 구현 정확도와 서버 소프트웨어, 지원하는 암호화 알고리즘에 달려있다.
        - 금융 정보나 메일 등 중요한 정보를 주고받는 것은 HTTPS를, 아무나 봐도 상관 없는 페이지는 HTTP를 사용한다.

- HTTPS가 필요한 이유?
    - 클라이언트인 웹브라우저가 서버에 HTTP를 통해 웹 페이지나 이미지 정보를 요청하면 서버는 이 요청에 응답하여 요구하는 정보를 제공하게 된다.
    - 웹 페이지(HTML)는 텍스트이고, HTTP를 통해 이런 텍스트 정보를 교환하는 것이다.
    - 이때 주고받는 텍스트 정보에 주민등록번호나 비밀번호와 같이 민감한 정보가 포함된 상태에서 네트워크 상에서 중간에 제3자가 정보를 가로챈다면 보안상 큰 문제가 발생한다.
    - 즉, 중간에서 정보를 볼 수 없도록 주고받는 정보를 암호화하는 방법인 HTTPS를 사용하는 것이다.

- HTTPS의 원리 
    - **[공개키 알고리즘 방식](https://github.com/WeareSoft/tech-interview/blob/master/contents/security.md#대칭키와-비대칭키-차이)**
    - **[SSL 참고하기 goodgid](https://goodgid.github.io/TLS-SSL/)**
    - 암호화, 복호화시킬 수 있는 서로 다른 키(공개키, 개인키)를 이용한 암호화 방법 
        - 공개키: 모두에게 공개. 공캐키 저장소에 등록 
        - 개인키(비공개키): 개인에게만 공개. 클라이언트-서버 구조에서는 서버가 가지고 있는 비공개키 
    - 클라이언트 -> 서버 
        - 사용자의 데이터를 **공개키로 암호화** (공개키를 얻은 인증된 사용자)
        - 서버로 전송 (데이터를 가로채도 개인키가 없으므로 **복호화할 수 없음**)
        - 서버의 **개인키를 통해 복호화**하여 요청 처리 

- HTTPS의 장단점
    - 장점 
        - 네트워크 상에서 열람, 수정이 불가능하므로 안전하다.
    - 단점 
        - 암호화를 하는 과정이 웹 서버에 부하를 준다.
        - HTTPS는 설치 및 인증서를 유지하는데 추가 비용이 발생한다.
        - HTTP에 비해 느리다. 
        - 인터넷 연결이 끊긴 경우 재인증 시간이 소요된다.
            - HTTP는 비연결형으로 웹 페이지를 보는 중 인터넷 연결이 끊겼다가 다시 연결되어도 페이지를 계속 볼 수 있다.
            - 그러나 HTTPS의 경우에는 소켓(데이터를 주고 받는 경로) 자체에서 인증을 하기 때문에 인터넷 연결이 끊기면 소켓도 끊어져서 다시 HTTPS 인증이 필요하다.


### HTTP와 HTTPS 동작 과정
#### HTTP 동작 과정
* 서버 접속 -> 클라이언트 -> 요청 -> 서버 -> 응답 -> 클라이언트 -> 연결 종료
1. **사용자가 웹 브라우저에 URL 주소 입력**
2. **DNS 서버에 웹 서버의 호스트 이름을 IP 주소로 변경 요청**
3. **웹 서버와 TCP 연결 시도**
    * 3way-handshaking
4. **클라이언트가 서버에게 요청**
    * HTTP Request Message = Request Header + 빈 줄 + Request Body
    * Request Header
      * 요청 메소드 + 요청 URI + HTTP 프로토콜 버전
        * ```GET /background.png HTTP/1.0``` ```POST / HTTP 1.1```
        * Header 정보(key-value 구조)
    * 빈 줄
      * 요청에 대한 모든 메타 정보가 전송되었음을 알리는 용도
    * Request Body
      * GET, HEAD, DELETE, OPTIONS처럼 리소스를 가져오는 요청은 바디 미포함
      * 데이터 업데이트 요청과 관련된 내용 (HTML 폼 콘텐츠 등)
5. **서버가 클라이언트에게 데이터 응답**
    * HTTP Response Message = Response Header + 빈 줄 + Response Body
    * Response Header
      * HTTP 프로토콜 버전 + 응답 코드 + 응답 메시지
        * ex. ```HTTP/1.1 404 Not Found.```
      * Header 정보(key-value 구조)
    * 빈 줄
      * 요청에 대한 모든 메타 정보가 전송되었음을 알리는 용도
    * Response Body
      * 응답 리소스 데이터
        * 201, 204 상태 코드는 바디 미포함
6. **서버 클라이언트 간 연결 종료**
    * 4way-handshaking
7. **웹 브라우저가 웹 문서 출력**

#### HTTPS(SSL) 동작 과정
* 공개키 암호화 방식과 대칭키 암호화 방식의 장점을 활용해 하이브리드 사용
  * 데이터를 대칭키 방식으로 암복호화하고, 공개키 방식으로 대칭키 전달
1. **클라이언트가 서버 접속하여 Handshaking 과정에서 서로 탐색**
    
    1.1. **Client Hello**
      * 클라이언트가 서버에게 전송할 데이터
        * 클라이언트 측에서 생성한 **랜덤 데이터**
        * 클-서 암호화 방식 통일을 위해 **클라이언트가 사용할 수 있는 암호화 방식**
        * 이전에 이미 Handshaking 기록이 있다면 자원 절약을 위해 기존 세션을 재활용하기 위한 **세션 아이디**

    1.2. **Server Hello**
      * Client Hello에 대한 응답으로 전송할 데이터
        * 서버 측에서 생성한 **랜덤 데이터**
        * **서버가 선택한 클라이언트의 암호화 방식**
        * **SSL 인증서**

    1.3. **Client 인증 확인**
      * 서버로부터 받은 인증서가 CA에 의해 발급되었는지 본인이 가지고 있는 목록에서 확인하고, 목록에 있다면 CA 공개키로 인증서 복호화
      * 클-서 각각의 랜덤 데이터를 조합하여 pre master secret 값 생성(데이터 송수신 시 대칭키 암호화에 사용할 키)
      * pre master secret 값을 공개키 방식으로 서버 전달(공개키는 서버로부터 받은 인증서에 포함)
      * 일련의 과정을 거쳐 session key 생성

    1.4. **Server 인증 확인**
      * 서버는 비공개키로 복호화하여 pre master secret 값 취득(대칭키 공유 완료)
      * 일련의 과정을 거쳐 session key 생성

    1.5. **Handshaking 종료**
2. **데이터 전송**
    * 서버와 클라이언트는 session key를 활용해 데이터를 암복호화하여 데이터 송수신
    
3. **연결 종료 및 session key 폐기**            


### HTTP 200, 300, 400, 500 응답 코드 (추가 예정)

- 100 번대  Informational (정보), 리퀘스트를 받고, 처리 중에 있음.

- 200 번대 응답(Response) : 성공(Success)

- 300 번대 응답(Response) : 리디렉션(Redirection)

- 400 번대 응답(Response) : 클라이언트 에러 (Client Error)

- 500 번대 응답(Response) : 서버 에러 (Server Error)

### 브라우저에 URL인 www.google.com 치면 나오는 과정

- [참조](https://owlgwang.tistory.com/1)하였습니다.

1. 주소표시줄에 URL을 입력하고 Enter를 입력한다.

2. 웹 브라우저가 URL을 해석한다.

URL의 구조
scheme:[//[user:password@]host[:port]][/]path[?query][#fragment]

URL 문법 
URL은 제일 앞에 자원에 접근할 방법을 정의해 둔 프로토콜 이름을 적는다. gopher, telnet, ftp, http, usenet 등이다.
프로토콜 이름 다음에는 프로토콜 이름을 구분하는 구분자인 ":"을 적는다.
만약 IP 혹은 Domain name 정보가 필요한 프로토콜이라면 ":" 다음에 "//"를 적는다.[3]
프로토콜명 구분자인 ":" 혹은 "//" 다음에는 프로토콜 마다 특화된 정보를 넣는다.

예1) http://www.somehost.com/a.gif- IP 혹은 Domain name 정보가 필요한 형태 ( www.somehost.com에 있는 a.gif를 가리키고 있음 )
예2) ftp://id:pass@192.168.1.234/a.gif- IP 혹은 Domain name 정보가 필요한 형태 ( 192.168.1.234에 있는 a.gif를 가리키고 있음 )
예3) mailto:somebody@mail.somehost.com - IP정보가 필요없는 프로토콜 ( mailto 프로토콜은 단지 메일을 받는 사람의 주소를 나타냄 )
 출처) 위키백과 - URL


만약, URL이 문법에 맞지 않는다면 입력을 웹 브라우저의 기본 검색엔진으로 검색을 요청한다.


3. URL이 문법에 맞으면 Punycode encoding을 url의 host부분에 적용한다.


4. HSTS (HTTP Strict Transport Security)목록을 로드해서 확인한다.


HSTS 목록에 있으면 첫 요청을 HTTPS로 보내고, 아닌경우 HTTP로 보낸다.
HTTP Strict Transport Security란? 

 - HTTP 대신 HTTPS만을 사용하여 통신해야 한다고 웹 사이트가 웹 브라우저에 알리는 보안기능
 출처) MDN - Strict Transport Security


5. DNS정보 브라우저 캐시에서 찾고 맵핑된 IP를 찾고 os에서 시스템콜로찾고 라우터가 가지고 있는지 찾고 isp같은곳에도 요청해서 찾습니다.
   그후 DNS(Domain Name Server) 조회한다.

  1) DNS에 요청을 보내기 전에 먼저 Browser에 해당 Domain이 cache돼 있는지 확인한다. (Chrome의 경우 chrome://net-internals/#dns 에서 확인 가능)
  2) 없을 경우 로컬에 저장돼 있는 hosts파일에서 참조할 수 있는 Domain이 있는지 확인한다.
  3) 1), 2)가 모두 실패 했을 경우 Network stack에 구성돼 있는 DNS로 요청을 보낸다. (DNS는 일반적으로 Local router, ISP의 캐싱 DNS)



6. ARP(Address Resolution Protocol)로 대상의 IP와 MAC address를 알아낸다.

  ARP broadcast를 보내려면 Network stack library가 조회 할 대상 IP 주소와 ARP broadcast에 사용할 인터페이스의 MAC address를 알아야 한다.
  ARP cache는 대상 IP에 대한 ARP 항목을 확인해서 cache가 있을경우 MAC주소를 반환한다.
  ARP cache가 없는 경우 : 

   1) 대상 IP address가 local subnet에 있는지 확인하기 위해 routing table 조회
   2) 있는경우 subnet과 연관된 interface 사용, 없는 경우 기본 gateway의 subnet과 연관된 interface 사용
   3) Network library는 Link Layer(OSI Model Layer 2)에 ARP 요청을 보냄



ARP Request:

Sender MAC: interface:mac:address:here
Sender IP: interface.ip.goes.here
Target MAC: FF:FF:FF:FF:FF:FF (Broadcast)
Target IP: target.ip.goes.here
ARP Reply:

Sender MAC: target:mac:address:here
Sender IP: target.ip.goes.here
Target MAC: interface:mac:address:here
Target IP: interface.ip.goes.here

    4) 응답에서 target의 MAC address와 IP address로 DNS 프로세스 다시 시작
    5) DNS에 53번 포트를 열어서 UDP 요청을 보낸다. (응답 데이터가 큰경우 TCP가 대신 사용)
    6) 로컬 / ISP DNS에 없는 경우 SOA(Service-oriented architecture)에 도달 할 때까지 재귀요청을 보내서 응답을 받는다.



7. 대상과 TCP 통신을 통해 Socket을 연다.

  1) 브라우저가 대상 서버의 IP 주소를 받으면 URL에서 해당 포트 번호(HTTP의 기본값은 80, HTTPS의 기본값은 443)를 가져와서, TCP Socket stream 요청
  2) TCP segment가 만들어지는 Transport Layer(OSI Model Layer 4)로 전달. 대상 포트 header에 추가되고 source port는 시스템에서 동적 포트 범위내에서 임의 지정
  3) TCP segment를 Network Layer(OSI Model Layer 3)로 전달. segment header에 대상 컴퓨터의 IP주소와 현재 컴퓨터의 IP주소가 삽입된packet 구성
  4) packet이 Link Layer(OSI Model Layer 2)로 전달. 시스템의 MAC address와 gateway(local router)의 MAC주소를 포함하는 Frame header 추가 (gateway의 MAC address를 모르는경우 ARP를 이용해 찾아야 한다.)
  5) packet이 ethernet, Wifi, Cellular data network 중 하나로 전송 
    - 광인터넷을 쓸 경우 modem을 통해 광신호로 변경된 후 network node로 직접 전송
  6) packet local subnet router 도착, AS(Autonomous System)경계 router들을 통과
      해당 라우터에선 packet의 IP header에서 target address를 추출하여 적당한 다음 hop으로 routing 
      IP header의 TTL(Time To Live)필드는 통과하는 라우터의 대해 하나씩 감소
      TTL필드가 0이 되거나 현재 router 대기열에 공간이 없으면 네트워크 정체로 packet 삭제
   7) TCP socket 통신 과정 

8. HTTPS인 경우 TLS(Transport Layer Security) handshake가 추가된다. 
  TLS는 SSL(Secure Sockets Layer)이 표준화 되면서 바뀐 이름이다. HTTPS로 통신을 하게 되면 TCP socket 통신과정 전에 아래와 그림과 같은 통신이 추가 된다. 여기서 시간은 큰 의미는 없다.


9. HTTP 프로토콜로 요청한다.
  그냥 HTTP라면 7번의 connection set-up 이후 부터이고, HTTPS라면 8번에 있는 그림에서 168ms 부터이다.
  client가 HTTP 프로토콜을 사용해서 서버에 다음과 같은 형식으로 요청을 보낸다.

GET / HTTP/1.1
Host: google.com
Connection: close
[other headers]
  여기서 other headers는 콜론(:) 으로 구분된 key, value 쌍을 말하며 HTTP 사양에 따라 형식이 지정되고 단일의 한 행으로 구분된다. (HTTP header 목록)
  영구 연결을 지원하지 않는 HTTP / 1.1 은 응답이 완료된 후 연결이 닫히도록 하는 close 연결 옵션을 포함해야 한다.

Connection: close
  요청과 header를 보낸 후 웹 브라우저는 요청 내용이 완료되었음을 알리는 단일 빈 줄 바꿈을 서버에 보낸다.
  서버는 상태를 나타내는 코드를 아래와 같은 형식으로 응답한다.

200 OK

[response headers]

   이 응답에 빈 줄이 한줄 들어가고 google.com의 HTML 내용의 Payload를 보낸다. 이 후에 서버는 연결을 close 할 수도 있고, 클라이언트가 보낸 헤더가 요청한 경우 추가 요청을 위해 연결을 유지 할 수도 있다.

   만약 웹 브라우저가 보낸 HTTP header에 웹 브라우저가 캐시한 파일의 버전이 마지막 검색이후 수정되지 않았으면(HTTP header의 ETag 값으로 확인) 서버에선 다음과 같이 응답한다. 

304 Not Modified
[response headers]
  이 응답에선 Payload가 없고 웹 브라우저는 캐시에서 HTML을 검색한다. HTML을 파싱한 후 웹 브라우저와 서버는 GET / HTTP/1.1요청이 아닌 HTML페이지에서 참조하는 모든 자원(Image, CSS, favicon.ico 등)에 대해 이 프로세스를 반복한다. 만약 HTML이 다른 Domain의 resource를 참조하는 경우 웹 브라우저는 다른 도메인을 확인하는 단계(5번 단계)로 돌아가고 해당 도메인에 대해 모든 단계를 수행한다. Host 요청의 header는 해당 서버의 이름으로 설정된다.


10. HTTP 서버가 응답한다.
  HTTPD(HTTP daemon) 서버는 요청 / 응답을 처리하는 서버이다. 가장 일반적인 HTTPD 서버는 Linux의 경우 Apache 또는 Nginx이고 Windows의 경우 IIS이다.
  1) HTTPD 서버가 요청을 수신
  2) 서버는 요청을 다음 매개변수로 구분

    - HTTP method (GET, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, HEAD). 주소 표시줄에 직접 입력한 url의 경우는 GET
    - 도메인 (여기서는 google.com)
    - 요청 된 경로 ( /path 형태, 여기서는 /, 기본경로)

  3) 서버는 google.com에 해당하는 서버에 구성된 가상 호스트가 있는지 확인 (하나에 서버에서 여러 도메인을 서비스 할 수 있음)
  4) 서버는 google.com이 GET 요청을 수락할 수 있는지 확인
  5) 서버는 클라이언트가 IP, 인증 등을 통해 이 method를 사용할 수 있는지 확인
  6) 서버에 rewrite module이 설치 돼 있으면 (예 : Apache의 경우 mod_rewrite, IIS의 경우 URL Rewrite) 요청 된 rule 중 하나와 일치하도록 시도, 일치하는 rule 이 있는 경우 서버는 해당 rule을 사용하여 요청을 다시 작성
  7) 서버는 요청에 해당하는 콘텐츠를 가져오고, 여기서는 "/"가 기본 경로이므로 이 경우 index파일을 해석
  8) 서버는 핸들러에 따라 파일을 구문 분석한다. php인 경우는 php를 사용하여 index파일 해석 후 출력을 클라이언트로 스트리밍


11. 웹 브라우저가 그린다. 

  서버가 리소스(HTML, CSS, JS, Image 등)를 브라우저에 제공하면 브라우저는 아래 프로세스를 수행한다.
   - 구문 분석 - HTML, CSS, JS
   - 렌더링 - DOM Tree 구성 -> 렌더 트리 구성 -> 렌더트리 레이아웃 배치 -> 렌더트리 그리기

  웹 브라우저의 기능은 서버에서 요청하고 브라우저 창에 표시하여 선택한 웹 리소스를 표시하는 것이다. 리소스는 일반적으로 HTML문서이지만 PDF, 이미지 또는 다른 유형의 콘텐츠일 수도 있다. 자원의 위치는 URI(Uniform Resource Identifier)를 사용하여 사용자가 지정한다.

  브라우저가 HTML파일을 해석하고 표시하는 방법은 HTML 및 CSS 사양에 지정되어 있다. 이 사양은 웹 표준 단체인 W3C(World Wide Web Consortium)에서 관리한다.
  브라우저의 일반적인 User Interface 요소

  - URI를 입력하기 위한 주소표시줄
  - 뒤로 및 앞으로 버튼
  - 북마크 버튼
  - 새로고침 및 중지 버튼
  - 홈페이지 이동 버튼


  브라우저 자세한 구조

  - User InterFace : 사용자 인터페이스는 주소 표시줄, 뒤로 / 앞으로 버튼, 북마크 메뉴 등 포함. 요청한 페이지가 표시된 창을 제외하고 브라우저의 모든 부분
  - Browser Engine : Browser Engine은 UI와 Rendering Engine 사이의 작업을 통제
  - Rendering Engine : Rendering Engine은 요청된 콘텐츠를 표시한다. HTML의 경우 Rendering Engine은 HTML과 CSS를 구문 분석하고 파싱된 컨텐츠를 화면에 표시
  - Networking : Networking은 인터페이스와 독립적으로 구현되어 HTTP 요청과 같은 Network호출을 처리
  - UI backend : UI backend는 콤보 상자 및 창과 같은 기본 위젯을 그리는 데 사용. 특정 플랫폼이 아닌 일반 인터페이스 제공. 운영체제 사용자 인터페이스 method 사용
  - Javascript Engine : Javascript 코드를 구문 분석하고 실행하는 데 사용.
  - Data Storage : 브라우저는 쿠키와 같이 모든 종류의 데이터를 로컬로 저장해야 할 수도 있음. localStorage, IndexedDB, WebSQL, File System과 같은 저장 수단을 지원


  HTML parsing
  - 렌더링 엔진은 요청 된 문서의 내용을 네트워킹 계층에서 가져옴. 보통 8Kb단위로 이루어짐
  - HTML의 마크업을 parse tree로 만드는 HTML parser의 기본 작업
  - 생성된 트리(parse tree)는 DOM(Document Object Model)노드와 속성 노드의 트리이다. Javascript와 같이 HTML문서의 객체 표현과 HTML 요소의 인터페이스 이고, 트리의 root는 "Documnet"객체이다. 스크립팅을 통한 조작 전에는 마크업과 DOM은 거의 일대일 관계를 유지

  Parsing 알고리즘
  - HTML은 regular top-down 방식이나 bottom-up parsers를 사용할 수 없음
  - 이유 

    1) 관대한 언어이다.

    2) 브라우저는 잘못된 HTML을 지원하기 위해 일반적인 오류 허용 범위를 갖고 있다.

    3) HTML이 파싱되는 동안 변경될 가능성이 있다.(document.write()를 사용해서 동적 코드로 토큰을 추가할 수 있다.)

  - 일반적인 parsing 기술을 사용할 수 없이 때문에 HTML을 구문 분석하기 위한 사용자 정의 parser를 사용. 구문분석 알고리즘은 HTML5 사양에 자세히 명세돼 있음.

  - 이 알고리즘은 토큰화와 트리구조화의 두 단계로 구성



  구문분석이 끝나면 브라우저는 페이지에 연결된 외부 리소스(CSS, Image, Javascript file)를 가져 온다. 이 단계에서 브라우저는 분서를 대화형으로 표시하고 문서가 구문 분석 된 후에 실행되어야 하는 "deferred"모드의 스크립트를 구문 분석한다. 문서 상태가 "complete"로 설정 되고 "load"이벤트가 발생한다.

  HTML 페이지에는 "Invalid Syntax"오류가 없다. 브라우저가 잘못된 콘텐츠를 고쳐서 계속한다.

  CSS parsing

  - "CSS lexical and syntax grammar"를 사용하여 CSS파일, <style>태그 내용 및 style 속성 값을 parsing한다.

  - 각 CSS file은 StyleSheet object로 parsing된다. 각 object에는 CSS문법에 해당하는 선택자와 객체가 일치하는 CSS 문법이 있다.

  - CSS parser는 regular top-down 방식이거나 bottom-up parsers일 수 있다.

  Page Rendering

  1) DOM 노드를 탐색하고 각 노드에 대한 CSS 값을 계산하여 "Frame tree" 또는 "Render tree"를 만듦.

  2) 자식 노드의 width와 수평 margin, border, padding 을 합해서 Frame tree의 아래쪽에 있는 각 노드의 기본 너비를 계산.

  3) 각 노드의 사용 가능한 너비를 자식 노드에 할당하여 각 노드의 실제 width 값 계산.

  4) 텍스트 배치를 적용하고 하위 노드의 height와 margin, border, padding을 합해 각 노드의 높이를 상향식으로 계산.

  5) 위에서 계산 된 정보를 사용해서 각 노드의 좌표를 계산.

  6) float, absolutely, relatively 와 같은 속성이 사용되었을 경우 더 복잡한 단계가 수행 된다. 

  7) 페이지의 어느 부분을 그룹으로 애니메이션화 할 수 있는지 설명하는 레이어를 만듦. frame/render object는 layer에 할당

  8) 텍스처는 페이지의 각 레이어에 할당

  9) 각 frame/render object를 통해서 각 레이어 별로 그리기 명령을 실행.

  10) 위의 모든 단계를 웹페이지가 렌더링 된 마지막 시간에 계산 된 값을 재사용 할 수 있으므로 점진적 변경은 작업이 덜 필요하다.

  11) 페이지 레이어는 합성 프로세스로 보내져 browser chrome, iframe, addon panels과 같은 시각적인 레이어와 결합된다.

  12) 최종 레이어 위치가 계산되고 Direct3D / OpenGL을 통해 합성 명령이 실행된다. GPU 명령 버퍼는 비동기 렌더링을 위해 GPU로 출력되고 frame은 window server로 전송된다.
 

  GPU rendering

  - 렌더링 프로세스 동안 graphical computing layers는 CPU 또는 GPU를 사용할 수 있다.
  - graphical rendering 계산에 GPU를 사용하는 경우 그래픽 소프트웨어 레이어에서 작업을 여러조각으로 분할하여 렌더링 프로세스에 필요한 부동 소수점 계산을 위해 GPU 대용량 병렬 처리를 사용 할 수 있다.

  렌더링이 완료된 후 브라우저는 Javascript 실행을 통해 DOM과 CSSOM이 변경 될 수 있는데 레이아웃이 수정 되는 경우 페이지 렌더링 및 페인팅을 다시 수행한다.


### GET 메서드와 POST 메서드, 멱등성

- [참조](https://hongsii.github.io/2017/08/02/what-is-the-difference-get-and-post/) 하였습니다.

1. GET
HTTP/1.1 스펙인 RFC2616의 Section9.3에 따르면 GET은 서버로부터 정보를 조회하기 위해 설계된 메소드입니다.
GET은 요청을 전송할 때 필요한 데이터를 Body에 담지 않고, 쿼리스트링을 통해 전송합니다. URL의 끝에 ?와 함께 이름과 값으로 쌍을 이루는 요청 파라미터를 쿼리스트링이라고 부릅니다. 만약, 요청 파라미터가 여러 개이면 &로 연결합니다. 쿼리스트링을 사용하게 되면 URL에 조회 조건을 표시하기 때문에 특정 페이지를 링크하거나 북마크할 수 있습니다.

쿼리스트링을 포함한 URL의 샘플은 아래와 같습니다. 여기서 요청 파라미터명은 name1, name2이고, 각각의 파라미터는 value1, value2라는 값으로 서버에 요청을 보내게 됩니다.

``` 
www.example-url.com/resources?name1=value1&name2=value2
```
그리고 GET은 불필요한 요청을 제한하기 위해 요청이 캐시될 수 있습니다. js, css, 이미지 같은 정적 컨텐츠는 데이터양이 크고, 변경될 일이 적어서 반복해서 동일한 요청을 보낼 필요가 없습니다. 정적 컨텐츠를 요청하고 나면 브라우저에서는 요청을 캐시해두고, 동일한 요청이 발생할 때 서버로 요청을 보내지 않고 캐시된 데이터를 사용합니다. 그래서 프론트엔드 개발을 하다보면 정적 컨텐츠가 캐시돼 컨텐츠를 변경해도 내용이 바뀌지 않는 경우가 종종 발생합니다. 이 때는 브라우저의 캐시를 지워주면 다시 컨텐츠를 조회하기 위해 서버로 요청을 보내게 됩니다.

2. POST
POST는 리소스를 생성/변경하기 위해 설계되었기 때문에 GET과 달리 전송해야될 데이터를 HTTP 메세지의 Body에 담아서 전송합니다. HTTP 메세지의 Body는 길이의 제한없이 데이터를 전송할 수 있습니다. 그래서 POST 요청은 GET과 달리 대용량 데이터를 전송할 수 있습니다. 이처럼 POST는 데이터가 Body로 전송되고 내용이 눈에 보이지 않아 GET보다 보안적인 면에서 안전하다고 생각할 수 있지만, POST 요청도 크롬 개발자 도구, Fiddler와 같은 툴로 요청 내용을 확인할 수 있기 때문에 민감한 데이터의 경우에는 반드시 암호화해 전송해야 합니다.

그리고 POST로 요청을 보낼 때는 요청 헤더의 Content-Type에 요청 데이터의 타입을 표시해야 합니다. 데이터 타입을 표시하지 않으면 서버는 내용이나 URL에 포함된 리소스의 확장자명 등으로 데이터 타입을 유추합니다. 만약, 알 수 없는 경우에는 application/octet-stream로 요청을 처리합니다.

- GET과 POST의 차이

GET은 Idempotent, POST는 Non-idempotent하게 설계되었습니다.
Idempotent(멱등)은 수학적 개념으로 다음과 같이 나타낼 수 있습니다.

수학이나 전산학에서 연산의 한 성질을 나타내는 것으로, 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질

즉, 멱등이라는 것은 동일한 연산을 여러 번 수행하더라도 동일한 결과가 나타나야 합니다.
여기서 GET이 Idempotent하도록 설계되었다는 것은 GET으로 서버에게 동일한 요청을 여러 번 전송하더라도 동일한 응답이 돌아와야 한다는 것을 의미합니다. 이에 따라 GET은 설계원칙에 따라 서버의 데이터나 상태를 변경시키지 않아야 Idempotent하기 때문에 주로 조회를 할 때에 사용해야합니다. 예를 들어, 브라우저에서 웹페이지를 열어보거나 게시글을 읽는 등 조회를 하는 행위는 GET으로 요청하게 됩니다.

반대로 POST는 Non-idempotent하기 때문에 서버에게 동일한 요청을 여러 번 전송해도 응답은 항상 다를 수 있습니다. 이에 따라 POST는 서버의 상태나 데이터를 변경시킬 때 사용됩니다. 게시글을 쓰면 서버에 게시글이 저장이 되고, 게시글을 삭제하면 해당 데이터가 없어지는 등 POST로 요청을 하게 되면 서버의 무언가는 변경되도록 사용됩니다. 이처럼 POST는 생성, 수정, 삭제에 사용할 수 있지만, 생성에는 POST, 수정은 PUT 또는 PATCH, 삭제는 DELETE가 더 용도에 맞는 메소드라고 할 수 있습니다.


### HTTP Restful API 정리 (더정리 필요)

-[여기 꼭보기, 참고](https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html)

- REST의 정의
```
Representational State Transfer” 의 약자
자원을 이름(자원의 표현)으로 구분하여 해당 자원의 상태(정보)를 주고 받는 모든 것을 의미한다.
즉, 자원(resource)의 표현(representation) 에 의한 상태 전달
자원(resource)의 표현(representation)
자원: 해당 소프트웨어가 관리하는 모든 것
-> Ex) 문서, 그림, 데이터, 해당 소프트웨어 자체 등
자원의 표현: 그 자원을 표현하기 위한 이름
-> Ex) DB의 학생 정보가 자원일 때, ‘students’를 자원의 표현으로 정한다.
```
- 상태(정보) 전달
데이터가 요청되어지는 시점에서 자원의 상태(정보)를 전달한다.
JSON 혹은 XML를 통해 데이터를 주고 받는 것이 일반적이다.
월드 와이드 웹(www)과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 개발 아키텍처의 한 형식
REST는 기본적으로 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 때문에 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일이다.
REST는 네트워크 상에서 Client와 Server 사이의 통신 방식 중 하나이다.

- REST의 구체적인 개념
HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미한다.
즉, REST는 자원 기반의 구조(ROA, Resource Oriented Architecture) 설계의 중심에 Resource가 있고 HTTP Method를 통해 Resource를 처리하도록 설계된 아키텍쳐를 의미한다.
웹 사이트의 이미지, 텍스트, DB 내용 등의 모든 자원에 고유한 ID인 HTTP URI를 부여한다.

- CRUD Operation
```
Create : 생성(POST)
Read : 조회(GET)
Update : 수정(PUT)
Delete : 삭제(DELETE)
HEAD: header 정보 조회(HEAD)
```

- RESTful 하지 못한 경우
1.  CRUD 기능을 모두 POST로만 처리하는 API
2.  route에 resource, id 외의 정보가 들어가는 경우(/students/updateName)


### 스케일 업, 스케일 아웃

1. 스케일 업(Scale-up)

Scale-up이란, 서버의 자체 성능을 증가시키는 것이라고 생각하시면 됩니다. 즉, 기존의 서버에서 더욱 고성능의 서버로 변경하는 것을 의미하며, 스케일 업을 "수직 스케일"이라고 부르기도 합니다. 

스케일 업의 문제점으로는 스토리지 컨트롤러의 확장성 한계의 문제, 성능 그리고 용량 확장 제한에 다다른 경우에 새 시스템을 추가해야되는데 이때 발생하는 마이그레이션 비용 등이 있습니다.

2. 스케일 아웃(Scale-out)

Scale-out이란, 기존의 서버와 같은 사양 또는 비슷한 사양의 서버 대수를 증가시키는 방법으로 처리 능력을 향샹시키는 것입니다. 스케일 아웃 방식을 "수평 스케일"이라고 부르기도 하고, 확장이 스케일 업보다는 다소 유연하다고 합니다.

스케일 업의 문제점으로는, 병렬 컴퓨팅의 어려움(설계 및 구현), 기본적으로 직렬화(단일 처리)되어야 할 부분이 존재하며, 기술적으로 문제점(대역폭, 동기화 문제), 코어가 늘어남에 따라 마냥 성능이 증가하지는 않고, 코어 증가에 따라 대역폭은 증가해 지연이 발행할 가능성이 있습니다.

3. 결론

주어진 환경에서 어떤 방식을 채택해서 더욱 실용적으로 구축해서 사용하는 것을 권장해드립니다. 예를 들면, 웹사이트의 접속자가 증가해서 트래픽이 많이 발생할 경우에는 scale-out이 scale-up 보다는 효

### 비동기, 동기 방식 통신(더 정리 필요)

- iocp는 비동기적, select는 동기적. 

select는 선택한 이벤트를 처리 가능할 때를 기다리는. iocp는 처리할 작업을 등록하는 방식.

select는 반환이 되더라도 완료가 된 것이 아닌, 처리가 가능할 때를 의미(또는 타임아웃). 

iocp는 작업을 등록하고 완료를 통지받는 것. 때문에 select의 경우 수신을 걸더라도 버퍼를 등록할 필요가 없고, iocp는 데이터를 담을 버퍼가 필요한 것.


### 셰션 vs 쿠키

```
세션 정보는 세션은 서버에 저장되는거고 브라우저에서 확인할수 있느건 쿠키값입니다.
JSESSIONID는  name 과 value 는 쿠키의 key-value 를 말하는 것입니다. 
구현하기에 따라 다른데 보통 사용자 정보를 서버에 저장하고그 저장된 키값을 쿠키에 담아서 브라우저로 보내줍니다
그럼 나중에 브라우저에서 요청을 할 때 쿠키값을 같이 받아서 그걸 기반으로 서버에서 다시 사용자 정보를 찾습니다.
그래서 로그인 정보가 있다면 세션 정보는 개발자 도구가 아니라 서버에서 확인하실 수 있을겁니다
세션 스토리지는 일반적으로 생각하는 로그인 세션이 아니라 브라우저에서 제공하는 웹스토리지라서 이거는 따로 공부해보시는게 좋을것 같다고합니다.
```

## 2. 운영체제

### 교착상태(데드락)이뭔지 교착상태 4개 조건

데드락 (Dead lock) 이란?

- ‘교착 상태’라고도 하며 한정된 자원을 여러 곳에서 사용하려고 할 때 발생할 수 있다.

발생 원인

- 멀티 프로그래밍 환경에서 한정된 자원을 사용하려고 서로 경쟁하는 상황이 발생 할 수 있다.

- 어떤 프로세스가 자원을 요청 했을 때 그 시각에 그 자원을 사용할 수 없는 상황이 발생할 수 있고 그 때는 프로세스가 대기 상태로 들어 간다.

- 대기 상태로 들어간 프로세스들이 실행 상태로 변경 될 수 없을 때 이러한 상황을 교착 상태라 한다.


- 교착 상태의 조건
1971년에 E. G. 코프만 교수는 교착상태가 일어나려면 다음과 같은 네 가지 필요 조건을 충족시켜야 함을 보였다.

- 상호배제(Mutual exclusion) : 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다.
- 점유대기(Hold and wait) : 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다.
- 비선점(No preemption) : 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다.
- 순환대기(Circular wait) : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.

이 조건 중에서 한 가지라도 만족하지 않으면 교착 상태는 발생하지 않는다. 이 중 순환대기 조건은 점유대기 조건과 비선점 조건을 만족해야 성립하는 조건이므로, 위 4가지 조건은 서로 완전히 독립적인 것은 아니다.

 
 - 데드락 (Dead lock) 처리

- 교착 상태 예방 및 회피 : 교착 상태가 되지 않도록 보장하기 위하여 교착 상태를 예방하거나 회피하는 프로토콜을 이용하는 방법

- 교착 상태 탐지 및 회복 : 교착 상태가 되도록 허용한 다음에 회복시키는 방법

- 교착 상태 무시 : 대부분의 시스템은 교착 상태가 잘 발생하지 않으며, 교착 상태 예방, 회피, 탐지, 복구하는 것은 비용이 많이 든다.

### 프로세스 vs 스레드

- 프로그램이란, 파일이 저장 장치에 저장되어 있지만 메모리에는 올라가 있지 않은 정적인 상태를 말한다.
- 프로세스: 운영체제로부터 자원을 할당받은 작업의 단위.
- 스레드: 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위.

- 왜 면접에서 물어볼까? **프로세스와 스레드의 작동 방식**에 대한 더 자세한 설명
위에서 프로세스가 메모리에 올라갈 때 운영체제로부터 시스템 자원을 할당받는다고 언급했었다. 
이 때 운영체제는 프로세스마다 각각 독립된 메모리 영역을, Code/Data/Stack/Heap의 형식으로 할당해 준다. 
각각 독립된 메모리 영역을 할당해 주기 때문에 프로세스는 다른 프로세스의 변수나 자료에 접근할 수 없다.
이와 다르게 스레드는 메모리를 서로 공유할 수 있다고 언급했었다. 이에 대해 더 자세히 설명하자면,
 프로세스가 할당받은 메모리 영역 내에서 Stack 형식으로 할당된 메모리 영역은 따로 할당받고,
  나머지 Code/Data/Heap 형식으로 할당된 메모리 영역을 공유한다. 따라서 각각의 스레드는 별도의 스택을 가지고 있지만 힙 메모리는 서로 읽고 쓸 수 있게 된다.

스레드는 본문 맨 위에서 "흐름의 단위"라고 말했는데, 정확히는 CPU 입장에서의 최소 작업 단위가 된다. 
CPU는 작업을 처리할 때 스레드를 최소 단위로 삼고 작업을 한다. 
반면 운영체제는 이렇게 작은 단위까지 직접 작업하지 않기 때문에 운영체제 관점에서는 프로세스가 최소 작업 단위가 된다.


###  멀티X, 멀티 프로세스(싱), 멀티 프로그램, 멀티 스레드(딩), 멀티 태스킹 (시험 문제)

- 멀티 프로세싱 (Multi-processing)

멀티 프로세싱은 다수의 프로세서가 서로 협력적으로 일을 처리하는 것을 의미한다.
컴퓨터는 1대인데 프로세서(CPU)는 2개 이상이다. 보통, 멀티코어시스템(multi-core system)을 포함한다.


- 멀티 태스킹 (Multi-tasking)

Task란 운영체제에서 처리하는 작업의 단위 또는 정해진 일을 수행하기 위한 명령어 집합을 뜻하는데 (process 보다 확장된 개념), 
멀티 태스킹은 task를 OS의 스케쥴링에 의해 task를 번갈아가며 수행하는 것을 의미한다.
여러개의 task를 자주 번갈아가며 수행하다보니 사용자는 동시에 여러 task가 수행되고 있다고 느끼게 된다.


- 멀티프로그래밍 와 멀티태스킹 비교

앞에서 말한 멀티 프로그래밍은 프로세서의 자원낭비를 막기 위함이고, 멀티태스킹은 정해진 시간동안 각각의 task를 번갈아가며 수행하는 것을 의미한다.

- 멀티 스레딩 (Multi-threading)

멀티 스레딩은 하나의 프로세스를 여러 개의 실행 단위이며, 여러 개의 스레드끼리 자원을 공유하는 것을 뜻한다.

프로세스: 실행될 때 OS로부터 자원을 할당받아 실행되는 프로그램

스레드: 한 프로세스 내에서 동작되는 여러 실행의 흐름

멀티프로세싱은 fork를 통해 프로세스를 다수개로 늘려 여러 개의 프로그램들을 병렬로 처리하며, 멀티스레딩은 하나의 프로그램 안에서 병렬 처리를 한다.
멀티 스레딩은 멀티 프로세싱보다 훨씬 적은 자원을 소모하기 때문에 더 효율적이나 안정성 측면에서는 멀티 프로세싱이 안정적이다.


- 멀티 스레딩 와 멀티 태스킹 비교

멀티 스레딩은 스레드들끼리의 자원 공유가 가능하며, 프로그래밍을 통해 구현 가능하나, 멀티 태스킹은 OS에서 지원하는 것으로 독립된 메모리를 가지며, 서로 간의 자원 공유가 이루어지지 않는다.
자원 공유를 위해 별도의 IPC (Inter-Process Communication)을 구현해야 하여, 멀테 스레딩에 비해 운영체제에게 부담을 줄 수 있다.

그럼 멀티 스레딩이 더 좋은 것이 아닌가?
꼭 그렇지만은 않다. 멀티 태스킹은 독립된 메모리를 가지고 있기 때문에 독립된 수행이 가능하다는 이점이 있다. 따라서 각각 적절하게 사용해야 한다.


### 세그멘테이션, 페이징

- 페이징(Paging)
```
논리(가상) 메모리는 페이지(Page)이라 불리는 고정 크기의 블록으로 나누어지고, 
물리 메모리는 프레임(Frame)라 불리는 페이지과 같은 크기의 블록들로 나누어짐. 보조 메모리 역시 프레임과 같은 크기의 블록들로 나누어짐.
사용자는 하나의 주소를 지정(하드웨어의 의해 페이지 번호와 변위로 분할)
페이지 테이블에는 각 페이지 번호와 그에 해당하는 프레임의 시작 물리 주소를 저장
할당은 항상 프레임의 정수 배로 할당되는데, 이 때 프로세스가 페이지 경계와 
일치하지 않는 크기의 메모리를 요구하게 되면 마지막 페이지 프레임은 전부 사용되지 않고 남아버리는 문제가 발생한다.(내부 단편화)
```

- 세그먼테이션(Segmentation)

```
페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, 
서로 다른 크기의 논리적 단위인 세그먼트(Segment)로 분할
사용자가 두 개의 주소로 지정(세그먼트 번호 + 변위)
세그먼트 테이블에는 각 세그먼트의 기준(세그먼트의 시작 물리 주소)과 한계(세그먼트의 길이)를 저장
서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 
자유 공간들이 많은 수의 작은 조각들로 나누어져 못 쓰게 될 수도 있다.(외부 단편화)

```

### 단편화 - 내부단편화, 외부단편화

- 메모리 단편화

RAM에서 메모리의 공간이 작은 조각으로 나뉘어져 사용가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태를 보고 메모리 단편화가 발생했다고 한다.

1. 내부 단편화

메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비 되는 현상
모리를 할당하는 최소 블록 크기를 10K라고 가정합시다.
만약 7K만큼의 공간을 사용하더라도 10K를 할당해야되고 나머지 3K를 낭비하게 됩니다.

2. 외부 단편화
메모리가 할당 및 해제 작업의 반복으로 작은 메모리가 중간중간에 존재 중간중간에 생긴 사용하지 않는 메모리가 존재해서 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황
여유 공간이 여러 조각으로 나뉘는 현상
프로세스 A,B,C 사이의 총 8K의 공간이 남아있습니다.
프로세스 D는 7K의 공간을 필요로 하므로, 남은 공간은 충분합니다.
그러나 분할하여 할당할 수 없으므로 프로세스D를 할당할 수 없는 문제가 발생합니다.

메모리 파편화 문제 해결 방법
1. 페이징(Paging)기법 - 가상메모리사용, 외부 단편화 해결, 내부 단편화 존재
보조기억장치를 이용한 가상메모리를 같은 크기의 블록으로 나눈 것을 페이지라고 하고 RAM을 페이지와 같은 크기로 나눈 것을 프레임이라고 할 때,

페이징 기법이란 사용하지 않는 프레임을 페이지에 옮기고, 필요한 메모리를 페이지 단위로 프레임에 옮기는 기법.

페이지와 프레임을 대응시키기 위해 page mapping과정이 필요해서 paging table을 만든다.

페이징 기법을 사용하면 연속적이지 않은 공간도 활용할 수 있기 때문에 외부 단편화 문제를 해결할 수 있다.

대신 페이지 단위에 알맞게 꽉채워 쓰는게 아니므로 내부 단편화 문제는 여전히 있다.

페이지 단위를 작게하면 내부 단편화 문제도 해결할 수 있겠지만 대신 page mapping 과정이 많아지므로 오히려 효율이 떨어질 수 있다.

2. 세그멘테이션(Segmentation)기법 - 가상메모리사용, 내부 단편화 해결, 외부 단편화 존재
페이징기법에서 가상메모리를 같은 크기의 단위로 분할했지만 세그멘테이션기법에서는 가상메모리를
서로 크기가 다른 논리적 단위인 세그먼트로 분할해서 메모리를 할당하여 실제 메모리 주소로 변환을 하게 된다.

각 세그먼트는 연속적인 공간에 저장되어 있다.

세그먼트들의 크기가 다르기 때문에 미리 분할해 둘 수 없고 메모리에 적재될 때 빈 공간을 찾아 할당하는 기법이다.

마찬가지로 mapping을 위해 세그먼트 테이블이 필요하다.

(각 세그먼트 항목별 세그먼트 시작주소와 세그먼트의 길이 정보를 가지고 있음)

프로세스가 필요한 메모리 만큼 할당해주기 때문에 내부단편화는 일어나지 않으나
여전히 중간에 프로세스가 메모리를 해제하면 생기는 구멍,
즉 외부 단편화 문제는 여전히 존재한다.

3. 메모리 풀(Memory Pool)
필요한 메모리 공간을 필요한 크기, 개수 만큼 사용자가 직접 지정하여 미리 할당받아 놓고 필요할 때마다 사용하고 반납하는 기법

메모리 풀 없이 동적할당과 해제를 반복하면 메모리의 랜덤한(실제로는 알고리즘에 의한) 위치에 할당과 해제가 반복되면서
단편화를 일으킬 수 있겠지만 미리 공간을 할당해놓고 가져다 쓰고 반납하기 때문에 할당과 해제로 인한 외부 단편화가 발생하지 않는다.

또한 필요한 크기만큼 할당을 해놓기 때문에 내부 단편화 또한 생기지 않는다.

하지만 메모리 단편화로 인한 메모리 낭비량보다 메모리 풀을 만들었지만 쓰지 않았을 때 메모리 양이 커질 경우 사용하지 않아야 한다.

메모리의 할당, 해제가 잦은 경우에 메모리 풀을 쓰면 효과적이다.

미리 할당해놓고 사용하지 않는 순간에도 계속 할당해놓으므로 메모리 누수가 있는 방식이다.

### 레이스컨디션, 동기화, 뮤텍스, 세마포어, 모니터

- 레이스 컨디션(Race Condition)이란?(기출)

한정된 공유 자원을 여러 프로세스가 동시에 이용하기 위해 경쟁을 벌이는 현상


이 셋은 모두 운영체제의 동기화 기법이다.

일단 뮤텍스와 세마포어부터 살펴보자.

운영체제에선 공유된 자원에 대해 여러 프로세스, 쓰레드가 접근하여 문제가 발생하는 것을 방지하고자 운영체제 동기화 기법을 만들었다.

1. 뮤텍스(Mutex, 상호배제) aka Mutual exclusion
공유된 자원의 데이터를 여러 쓰레드가 접근하는 것을 막는 것이다.

임계영역(Critical Section)을 가진 스레드들의 Running time이 서로 겹치지 않게 단독적으로 실행되게 하는 것.

다중 프로세스들의 공유 리소스에 대한 접근을 조율하기 위해 Locking과 Unlocking을 사용.

2. 세마포어(Semaphore)
세마포어도 뮤텍스와 마찬가지로 동기화 기법 중 하나.

뮤텍스가 임계 영역에 들어가는 스레드가 하나라면, 세마포어는 복수가 가능하다.

열쇠키가 여러개라고 보면 된다.

wait과 signal을 통해 구현한다.

일반적으로 , wait이 먼저 호출되며 임계영역에 들어갈 수 있는지 확인한다.

혹은, 먼저 실행되어야 하는 프로세스가 실행됐는지 확인한다. 조건에 만족하면 wait을 빠져나와 임계영역으로 들어간다.

이후 signal이 호출되고 임계영역에서 빠져나왔음을 알린다.

3. 모니터(Monitor)
뮤텍스는 다른 프로세스간에 동기화 할 때 사용할 수 있다는 것이고, 모니터는 하나의 프로세스 내에서 다른 스레드 간의 동기화에 사용된다는 것, 모니터는 프레임워크나 라이브러리 그 자체에서 제공된다. C언어에는 없고 Java에는 있다. 모니터는 일련의 동기화 작업들이 캡슐화되어 있어서 synchronized, wait(), notify()등의 키워드를 통해 좀 더 편하게 동기화 할 수 있다. 

즉, 달리 말해 세마포어는 귀찮게 임계구역 앞에 wait을 설정하고 끝나고 signal을 설정해줘야 하지만 모니터는 그럴 필요 없이 함수 앞에 synchronized를 붙여주기만 하면 알아서 상호배제하여 함수의 작업을 수행한다.

### 인터럽트, PCB, Context Switching

Context Switching이 무엇인가?

멀티프로세스 환경에서 CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 또는 레지스터 값(Context)을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(Context)를 교체하는 작업을 Context Switch(Context Switching)라고 한다.

질문에 대한 답변은 이정도로 하고 좀 더 명확하게 이해해본다.

* Context Switching을 문맥 교환으로 번역하지 말자.

Context는 무엇인가?

사용자와 다른 사용자, 사용자와 시스템 또는 디바이스간의 상호작용에 영향을 미치는 사람, 장소, 개체등의 현재 상황(상태)을 규정하는 정보들을 말한다.

android나 servlet등에서도 context가 있지만 OS에서 Context는 CPU가 해당 프로세스를 실행하기 위한 해당 프로세스의 정보들이다.

이 Context는 프로세스의 PCB(Process Control Block)에 저장된다.

그래서 Context Switching 때 PCB의 정보를 읽어(적재) CPU가 전에 프로세스가 일을 하던거에 이어서 수행이 가능한 것이다.

PCB의 저장정보

- 프로세스 상태 : 생성, 준비, 수행, 대기, 중지

- 프로그램 카운터 : 프로세스가 다음에 실행할 명령어 주소

- 레지스터 : 누산기, 스택, 색인 레지스터

- 프로세스 번호

* 참고로 Context Switching 때 해당 CPU는 아무런 일을 하지 못한다. 따라서 컨텍스트 스위칭이 잦아지면 오히려 오버헤드가 발생해 효율(성능)이 떨어진다.

Context가 뭔지 알았고 멀티프로세싱하기 위해 CPU를 나눠서 사용하기 위해 Context를 교체하는 것이 Context Switching임을 알았다. 그리고 PCB에 Context가 저장됨도 알았다.

남은 것은 인터럽트 요청이 뭐고 어떤 종류가 있는지 + 서브로 우선 순위에 대한 이야기다.

Context Switching - 인터럽트(Interrupt)

인터럽트는 CPU가 프로그램을 실행하고 있을 때 실행중인 프로그램 밖에서 예외 상황이 발생하여 처리가 필요한 경우 CPU에게 알려 예외 상황을 처리할 수 있도록 하는 것을 말한다.

어떤 인터럽트 요청이 와야 Context Switching이 일어날까?

1. I/O request (입출력 요청할 때)

2. time slice expired (CPU 사용시간이 만료 되었을 때)

3. fork a child (자식 프로세스를 만들 때)

4. wait for an interrupt (인터럽트 처리를 기다릴 때)

+ 더 있겠지만 자세한 것은 생략.

* 우선 순위는 해당 OS의 스케줄러가 우선 순위 알고리즘에 의해 정해지고 수행하게 되어있다.

라운드로빈 스케줄링(Round Robin Scheduling)은 시분할 시스템을 위해 설계된 선점형 스케줄링의 하나다.

쉽게 설명하면 순서대로 시간단위(Time Quantum)을 CPU에 할당하는 방식이다.

꽤 효율적인 스케줄링 알고리즘이지만 이 시간단위를 작게 설정하면 CPU가 조금 일하고 Context Switching을 반복하므로 아까 말했듯이 효율이 떨어진다.

* Context Switch를 하는 주체 = OS 스케줄러

### 사용자 수준 스레드와 커널 수준 스레드

커널 레벨(Kernel Level) 쓰레드와 유저 레벨(User Level) 쓰레드

1. 커널 모드와 유저 모드
메모리 영역은 사용자에 의해서 할당되는 메모리 공간인 유저 영역과 운영체제라는
하나의 소프트웨어를 실행시키기 위해서 필요한 메모리 공간인 커널 영역으로 나뉜다.

사용자가 사용하는 메모리 영역은 유저 영역이지만 C언어는 메모리 참조가 용이하기 때문에
안정성 제공 측면에서 커널 모드와 유저 모드가 사용된다.

기본적으로 유저 모드로 동작하다가 Windows 커널이 실행되어야 하는 경우에 커널 모드로의 전환이 일어난다.

커널 모드와 유저 모드의 차이는 유저 모드에서 동작할 때 커널 영역으로의 접근이 금지된다.
커널 모드일 때는 모든 영역의 접근이 허용된다.

Windows 에서 운영체제 차원에서 제공되는 시스템 함수들 중 일부는 호출시 커널 모드로 동작한다.
주의할 점은 모드의 전환은 시스템에 부담을 준다.

커널 모드와 유저 모드를 제공하는 대상은 Windows운영체제가 아닌 프로세서(Process)이다.
즉 메모리 보호 기능이 CPU에 달려있다.

2. 커널 레벨 쓰레드와 유저 레벨 쓰레드
커널 레벨 쓰레드와 유저 레벨 쓰레드는 생성 주체가 누구냐에 따라 구분된다.

프로그래머 요청에 따라 쓰레드를 생성하고 스케줄링하는 주체가 커널이면 커널 레벨(Kernel Level) 쓰레드라고 한다.

커널이 쓰레드 모델을 지원하지 않거나 제공하는 쓰레드 모델이 마음에 들지 않을 경우,
커널에 의존적이지 않은 형태로 쓰레드의 기능을 제공하는 라이브러리를 활용할 수 있는데
이러한 방식으로 제공되는 쓰레드가 유저 레벨(User Level) 쓰레드이다.

3. 커널 레벨 쓰레드와 유저 레벨 쓰레드 장/단점
커널 레벨 쓰레드의 장점은 커널이 직접 제공해 주기 때문에 안정성과 다양한 기능이 제공된다.

커널 레벨 쓰레드의 단점은 유저 모드에서 커널 모드로의 전환이 빈번하게 이뤄져 성능 저하가 발생한다.

유저 레벨 쓰레드의 장점은 커널은 쓰레드의 존재조차 모르기 때문에 모드 간의 전환이 없고 성능 이득이 발생한다.

유저 레벨 쓰레드의 단점은 하나의 스레드가 커널에 의해 블로킹 되면 프로세스 전체가 블로킹되고,
이를 해결하려면 프로그래밍이 어려워지고 커널 레벨 쓰레드에 비해 결과 예측이 어려워진다.

### 캐시의 지역성

캐시 지역성(Locality)이란?

- 프로세스가 시간/공간적으로 유사한 데이터를 집중적으로 참조하는 성질

캐시 지역성(Locality)의 유형

시간적(Temporal) 지역성

- 최근 사용된 데이터의 재 이용률이 높음

- Loop, Sub Routine

- LRU(Least Recently Used)는 시간적 지역성을 극대화 하기 위한 교체 기법

공간적(Spatial) 지역성

- 메모리 상 인접 데이터의 재 이용률이 높음

- 데이터베이스 파티션이 예

순차적(Sequential) 지역성

- 기억장치에 저장된 순서대로 이용될 가능성이 높음

- ex) 배열 데이터


## 3. 데이터베이스

### 인덱스

1. Index란?

: 자주 사용되는 칼럼에 대해서 따로 생성해 놓은 정렬된 테이블. 하나의 테이블이 객체라면, 인덱스 또한 객체가 생성된 것임. 정렬된 상태이기 때문에 어디부터 스캔할지 정하여 index range scan을 통해 full scan보다 빠르게 데이터에 접근할 수 있음

2. Index 종류

btree index (balanced tree)
cluster index
IOT
3. Index의 장점

: 데이터 테이블 full scan대신 더 빠르게 데이터에 접근할 수 있게 해줌. 즉 select절의 속도가 빨라짐.

4. Index의 단점

: insert, update의 속도가 저하됨. 정렬된 상태를 유지해야하고, 테이블 외에 인덱스 테이블에도 insert, update를 해줘야 하기 때문에, insert와 update가 빈번히 일어나는 테이블에 대해서는 index 설정이 성능에 부정적 영향을 줄 수도 있음

5. Index 설정 시 유의사항

두 가지 이상의 컬럼을 인덱스로 설정하는 결합 인덱스의 경우, 설정 순서가 중요함. 분별력이 높은 칼럼이 앞으로 오는 것이 성능 향상에 유리. ex) 성별보다는 id 칼럼을 앞 인덱스로 설정

### 트랙잭션

- 트랙잭션 특성 (ACID)

### 트랜잭션 고립화 레벨 

트랙잭션 : 데이터베이스 내에서 한꺼번에 수행되어야할 일련의 연산들 트랙잭션 의 모든 연산은 반드시 한꺼번에 완료가 되야 하며 그렇지 않은경우에는 한꺼번에 취소되어야 하는 원자성을 가지고 있습니다

한꺼번에 완료가 된경우에는 성공적인 종료 COMMIT 이 경우에는 작업결과는 데이터베이스에 반영이 되게 됩니다.

취소가 된경우에는 비정상적인 종료 ROLLBACK

원자성(Atomicity) - 분리 할수 없는 하나의 단위로 작업은 모두 완료되거나 모두 취소 되어야 합니다.

일관성(Consistency) - 사용되는 모든 데이터는 일관되어야 합니다.

격리성(Isolation) - 접근하고 있는 데이터는 다른 트랜잭션으로 부터 격리 되어야 합니다. 트랜잭션이 진행되기전과 완료된 후에 상태를 볼수 있지만 트랜잭션이 진행되는 중간 데이터는 볼수 없습니다.

영속성(Durability) - 트랙잭션이 정상 종료되면 그 결과는 시스템에 영구적으로 적용되어야 합니다.

순차성(Sequentiality) - 데이터를 다시 로드하고 트랜잭션을 재생하여 원래 트랜잭션이 수행된 후의 상태로 데이터를 되돌리는 것을 말합니다.

트랜잭션 고립화 레벨 DB는 무결성을 보장하는 것이 중요하다. Locking은 Transaction이 DB를 다루는 동안 다른 Transaction이 관여하지 못하게 막는다. 이와 관련된 Locking 방법이 Isolation Level이다. 0 : Read Uncommitted 트랜잭션 처리 중인 데이터를 읽을 수 있음 1: Read Committed 트랜잭션이 커밋되어 확정된 데이터만 읽을 수 있음 2: Repeatable Read 선행 트랜잭션이 데이터를 읽는 경우 종료 전까진 갱신/삭제 불가 3: Serializable 선행 트랜잭션이 데이터를 읽는 경우 종료 전까진 갱신/삭제/삽입 불가

부작용(Side Effect) Dirty Read 커밋되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할때 발생 Non-Repeatable Read 두 쿼리의 결과가 상이하게 나타나는 비일관성이 발생하는 것을 말함 Phantom Read 한 트랜잭션 안에서 일정 범위의 레코드를 두번 이상 읽을 때, 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상

### 정규화

- [참고](https://velog.io/@wldus9503/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%A0%95%EA%B7%9C%ED%99%94Normalization%EB%9E%80)

- 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연셩을 위한 방법이며 데이터를 분해하는 과정

- 정규화의 목적

그런데 하나의 테이블에 다 담을 수 있는데, 굳이 여러 테이블을 나누어서 저장을 해야할까요?

다양한 목적이 있지만, 대표적으로 두가지가 있습니다.

첫째, 불필요한 데이터(data redundancy)를 제거해 불필요한 중복을 최소화한다.

하나의 테이블에 모든 정보를 다 넣게 되면 동일한 정보들이 불필요하게 중복되어 저장될 수 있습니다.
그렇게다면 불필요하게 더 많은 디스크를 사용하게 됩니다

그래서 FK(외래키)로 PK(기본키)를 연결해 사용하면 디스크 공간을 훨씬 효율적으로 사용할 수 있답니다.

둘째, 삽입/갱신/삭제 시 발생할 수 있는 각종 이상 현상(Anomaly) 을 방지하기 위해서, 테이블의 구성을 논리적이고 직관적으로 한다.

그외에 데이터베이스 구조 확장 시 재디자인을 최소화, 다양한 관점에서의 query를 지원하기 위해서 등등의 목적도 존재합니다.

정규화의 대상
정규화와 반정규의 차이가 뭐죠?

정규화 - 온라인 거래 시스템 같은 OLTP(OnLine Transaction Processing) 데이터베이스는 CRUD(Create, Read, Update, Delete) 가 많이 일어나 정규화가 적절합니다.

반정규화 - 분석 리포트 같은 OLAP(OnLine Analytical Processing) 데이터베이스는 분석과 리포팅을 위해 사용되기 때문에 연산의 속도를 위해 반정규화를 사용하는 게 좋습니다.

*반정규화: 정규화된 시스템을 성능 향상 및 개발과 운영의 단순화를 위해 역으로 정규화를 수행하는 것을 말합니다. 일반적으로 join을 많이 사용해야 할 경우, 대량의 범위를 자주 처리하는 경우 등 조회에 대한 처리가 중요하다고 판단될 때 부분적으로 반정규화를 합니다.

- 제 1정규화(First Normal Form, 1NF) : 속성의 원자성(Atomic)을 확보, 기본키를 설정
- 제 2정규화(Second Normal Form, 2NF) : 기본키가 2개 이상의 속성으로 이루어진 경우, 부분 함수 종속성 제거
- 제 3정규화(Third Normal Form, 3NF) : 이행 함수 종속성 제거

### SQL vs NoSQL

- SQL의 장점
명확하게 정의 된 스키마, 데이터 무결성 보장
관계는 각 데이터를 중복없이 한번만 저장됩니다.

- NoSQL의 장점
스키마가 없기때문에, 훨씬 더 유연합니다. 즉, 언제든지 저장된 데이터를 조정하고 새로운 "필드"를 추가 할 수 있습니다.
데이터는 애플리케이션이 필요로 하는 형식으로 저장됩니다. 이렇게 하면 데이터를 읽어오는 속도가 빨라집니다.
수직 및 수평 확장이 가능하므로 데이터베이스가 애플리케이션에서 발생시키는 모든 읽기 / 쓰기 요청을 처리 할 수 있습니다.
그리고 단점은 아래와 같습니다.

- SQL의 단점
상대적으로 덜 유연합니다. 데이터 스키마는 사전에 계획되고 알려져야 합니다. (나중에 수정하기가 번거롭거나 불가능 할 수 도 있습니다.)
관계를 맺고 있기 때문에, JOIN문이 많은 매우 복잡한 쿼리가 만들어 질 수 있습니다.
수평적 확장이 어렵고, 대체로 수직적 확장만 가능합니다. 즉 어떤 시점에서 (처리 할 수 있는 처리량과 관련하여) 성장 한계에 직면하게 됩니다.

- NoSQL의 단점
유연성 때문에, 데이터 구조 결정을 하지 못하고 미루게 될 수 있습니다.
데이터 중복은 여러 컬렉션과 문서가 (SQL 세계에서 처럼 하나의 테이블에 하나의 레코드가 아니라) 여러 개의 레코드가 변경된 경우 업데이트를 해야 합니다.
데이터가 여러 컬렉션에 중복되어 있기 때문에, 수정(update)를 해야 하는 경우 모든 컬렉션에서 수행해야 함을 의미합니다. (SQL 세계에서는 중복된 데이터가 없기 때문에 한번만 수행하면 됩니다.)

- SQL은 언제 사용하는 것이 좋을까요?
관계를 맺고 있는 데이터가 자주 변경(수정)되는 애플리케이션일 경우 (NoSQL에서라면 여러 컬렉션을 모두 수정해줘야만 합니다.)
변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우

- NoSQL은 언제 사용하는 것이 좋을까요?
정확한 데이터 구조를 알 수 없거나 변경 / 확장 될 수 있는 경우
읽기(read)처리를 자주하지만, 데이터를 자주 변경(update)하지 않는 경우 (즉, 한번의 변경으로 수십 개의 문서를 업데이트 할 필요가 없는 경우)
데이터베이스를 수평으로 확장해야 하는 경우 ( 즉, 막대한 양의 데이터를 다뤄야 하는 경우)
분명한 것은 데이터베이스는 다른 방식으로 설계 될 수 있다는 겁니다. NoSQL 데이터베이스를 쓰더라도 설계적으로 언급된 단점들을 완화시킬 수 있습니다. (예를들면 중복된 데이터를 줄이는 방법). SQL 데이터베이스도 마찬가지입니다. 요구사항을 만족시키고, 복잡한 JOIN문을 만들지 않도록 설계할 수 있습니다. 

## SQL (관계형 데이터베이스)
SQL은 '구조화 된 쿼리 언어 (Structured Query Language)'의 약자입니다. 그러므로 데이터베이스 자체를 나타내는 것이 아니라, 특정 유형의 데이터베이스와 상호 작용하는 데 사용 하는 쿼리 언어입니다. (그러나 이 글에서는 SQL을 '관계형 데이터베이스' 라는 의미로도 사용합니다.)
SQL을 사용하면 관계형 데이터베이스 관리 시스템(RDBMS)에서 데이터를 저장, 수정, 삭제 및 검색 할 수 있습니다.
이러한 관계형 데이터베이스에는 두 가지 주요 특징이 있습니다.  
데이터는 정해진(엄격한) 데이터 스키마 (= structure)를 따라 데이터베이스 테이블에 저장됩니다.
데이터는 관계를 통해서 연결된 여러개의 테이블에 분산됩니다.

1. 엄격한 스키마
데이터는 테이블(table)에 레코드(record)로 저장되며, 각 테이블에는 명확하게 정의된 구조(structure)가 있습니다. (구조란 어떤 데이터가 테이블에 들어가고 어떤 데이터가 그렇지 않을지를 정의하는 필드(field) 집합을 가르킵니다.)
구조(structure)는 필드의 이름과 데이터 유형으로 정의됩니다.

2. 관계
SQL 기반의 데이터 베이스의 또 다른 중요한 부분은 관계입니다.
데이터들을 여러개의 테이블에 나누어서, 데이터들의 중복을 피할 수 있습니다. 만약 사용자가 구입한 상품들을 나타내기 위해서는, Users(사용자), Products(상품), Orders(주문한 상품) 여러 테이블을 만들어야 하지만, 각각의 테이블들은 다른 테이블에 저장되지 않은 데이터 만을 가지고 있습니다. (중복된 데이터가 없습니다.) 

## NoSQL (비관계형 데이터베이스)
NoSQL은 기본적으로 SQL(관계형 데이터베이스)와 반대되는 접근방식을 따르기 때문에 지어진 이름입니다.
스키마 없음
관계 없음
NoSQL세상에서는 레코드를 문서(documents)라고 부릅니다.
이것은 단순히 이름만 다른 것이 아니라, 핵심적인 차이점 이있습니다. SQL 세상에서는 정해진 스키마를 따르지 않는다면 데이터를 추가 할 수 없지만, NoSQL에서는 다른 구조의 데이터를 같은 컬렉션(= SQL에서의 테이블)에 추가할 수 있습니다.

### 정의

관계형 데이터 모델을 **지양** 하며 대량의 분산된 데이터를 저장하고 조회하는 데 특화되었으며 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소를 말한다.

종류마다 쓰기/읽기 성능 특화, 2 차 인덱스 지원, 오토 샤딩 지원 같은 고유한 특징을 가진다. 대량의 데이터를 빠르게 처리하기 위해 메모리에 임시 저장하고 응답하는 등의 방법을 사용한다. 동적인 스케일 아웃을 지원하기도 하며, 가용성을 위하여 데이터 복제 등의 방법으로 관계형 데이터베이스가 제공하지 못하는 성능과 특징을 제공한다.

</br>

### CAP 이론

### 1. 일관성(Consistency)

일관성은 동시성 또는 동일성이라고도 하며 다중 클라이언트에서 같은 시간에 조회하는 데이터는 항상 동일한 데이터임을 보증하는 것을 의미한다. 이것은 관계형 데이터베이스가 지원하는 가장 기본적인 기능이지만 일관성을 지원하지 않는 NoSQL 을 사용한다면 데이터의 일관성이 느슨하게 처리되어 동일한 데이터가 나타나지 않을 수 있다. 느슨하게 처리된다는 것은 데이터의 변경을 시간의 흐름에 따라 여러 노드에 전파하는 것을 말한다. 이러한 방법을 최종적으로 일관성이 유지된다고 하여 최종 일관성 또는 궁극적 일관성을 지원한다고 한다.

각 NoSQL 들은 분산 노드 간의 데이터 동기화를 위해서 두 가지 방법을 사용한다.
첫번째로 데이터의 저장 결과를 클라이언트로 응답하기 전에 모든 노드에 데이터를 저장하는 동기식 방법이 있다. 그만큼 느린 응답시간을 보이지만 데이터의 정합성을 보장한다.
두번째로 메모리나 임시 파일에 기록하고 클라이언트에 먼저 응답한 다음, 특정 이벤트 또는 프로세스를 사용하여 노드로 데이터를 동기화하는 비동기식 방법이 있다. 빠른 응답시간을 보인다는 장점이 있지만, 쓰기 노드에 장애가 발생하였을 경우 데이터가 손실될 수 있다.

</br>

### 2. 가용성(Availability)

가용성이란 모든 클라이언트의 읽기와 쓰기 요청에 대하여 항상 응답이 가능해야 함을 보증하는 것이며 내고장성이라고도 한다. 내고장성을 가진 NoSQL 은 클러스터 내에서 몇 개의 노드가 망가지더라도 정상적인 서비스가 가능하다.

몇몇 NoSQL 은 가용성을 보장하기 위해 데이터 복제(Replication)을 사용한다. 동일한 데이터를 다중 노드에 중복 저장하여 그 중 몇 대의 노드가 고장나도 데이터가 유실되지 않도록 하는 방법이다. 데이터 중복 저장 방법에는 동일한 데이터를 가진 저장소를 하나 더 생성하는 Master-Slave 복제 방법과 데이터 단위로 중복 저장하는 Peer-to-Peer 복제 방법이 있다.

</br>

### 3. 네트워크 분할 허용성(Partition tolerance)

분할 허용성이란 지역적으로 분할된 네트워크 환경에서 동작하는 시스템에서 두 지역 간의 네트워크가 단절되거나 네트워크 데이터의 유실이 일어나더라도 각 지역 내의 시스템은 정상적으로 동작해야 함을 의미한다.

</br>

### 저장 방식에 따른 NoSQL 분류

`Key-Value Model`, `Document Model`, `Column Model`, `Graph Model`로 분류할 수 있다.

### 1. Key-Value Model

가장 기본적인 형태의 NoSQL 이며 키 하나로 데이터 하나를 저장하고 조회할 수 있는 단일 키-값 구조를 갖는다. 단순한 저장구조로 인하여 복잡한 조회 연산을 지원하지 않는다. 또한 고속 읽기와 쓰기에 최적화된 경우가 많다. 사용자의 프로필 정보, 웹 서버 클러스터를 위한 세션 정보, 장바구니 정보, URL 단축 정보 저장 등에 사용한다. 하나의 서비스 요청에 다수의 데이터 조회 및 수정 연산이 발생하면 트랜잭션 처리가 불가능하여 데이터 정합성을 보장할 수 없다.
_ex) Redis_

### 2. Document Model

키-값 모델을 개념적으로 확장한 구조로 하나의 키에 하나의 구조화된 문서를 저장하고 조회한다. 논리적인 데이터 저장과 조회 방법이 관계형 데이터베이스와 유사하다. 키는 문서에 대한 ID 로 표현된다. 또한 저장된 문서를 컬렉션으로 관리하며 문서 저장과 동시에 문서 ID 에 대한 인덱스를 생성한다. 문서 ID 에 대한 인덱스를 사용하여 O(1) 시간 안에 문서를 조회할 수 있다.

대부분의 문서 모델 NoSQL 은 B 트리 인덱스를 사용하여 2 차 인덱스를 생성한다. B 트리는 크기가 커지면 커질수록 새로운 데이터를 입력하거나 삭제할 때 성능이 떨어지게 된다. 그렇기 때문에 읽기와 쓰기의 비율이 7:3 정도일 때 가장 좋은 성능을 보인다. 중앙 집중식 로그 저장, 타임라인 저장, 통계 정보 저장 등에 사용된다.
_ex) MongoDB_

### 3. Column Model

하나의 키에 여러 개의 컬럼 이름과 컬럼 값의 쌍으로 이루어진 데이터를 저장하고 조회한다. 모든 컬럼은 항상 타임 스탬프 값과 함께 저장된다.

구글의 빅테이블이 대표적인 예로 차후 컬럼형 NoSQL 은 빅테이블의 영향을 받았다. 이러한 이유로 Row key, Column Key, Column Family 같은 빅테이블 개념이 공통적으로 사용된다. 저장의 기본 단위는 컬럼으로 컬럼은 컬럼 이름과 컬럼 값, 타임스탬프로 구성된다. 이러한 컬럼들의 집합이 로우(Row)이며, 로우키(Row key)는 각 로우를 유일하게 식별하는 값이다. 이러한 로우들의 집합은 키 스페이스(Key Space)가 된다.

대부분의 컬럼 모델 NoSQL 은 쓰기와 읽기 중에 쓰기에 더 특화되어 있다. 데이터를 먼저 커밋로그와 메모리에 저장한 후 응답하기 때문에 빠른 응답속도를 제공한다. 그렇기 때문에 읽기 연산 대비 쓰기 연산이 많은 서비스나 빠른 시간 안에 대량의 데이터를 입력하고 조회하는 서비스를 구현할 때 가장 좋은 성능을 보인다. 채팅 내용 저장, 실시간 분석을 위한 데이터 저장소 등의 서비스 구현에 적합하다.

### 데이터베이스 키(Key) 정리

- 데이터 베이스 키(Key)의 개념 및 종류

키(Key)는 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 다른 튜플들과 구별할 수 있는 유일한 기준이 되는 Attribute(속성)입니다. 

*튜플 : 릴레이션을 구성하는 각각의 행, 속성의 모임으로 구성된다. 파일 구조에서는 레코드와 같은 개념, 튜플의 수 = 카디널리티(Cardinality) = 기수 = 대응수 

1. 후보키 (Candidate Key)

* 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별할 수 있는 속성들의 부분집합을 의미합니다. 

* 모든 릴레이션은 반드시 하나 이상의 후보키를 가져야합니다.

* 릴레이션에 있는 모든 튜플에 대해서 유일성과 최소성을 만족시켜야합니다.

ex) <학생> 릴레이션에서 '학번'이나 '주민번호'는 다른 레코드를 유일하게 구별할 수 있는 기본키로 사용할 수 있으므로 후보키가 될 수 있습니다. 즉

기본키가 될 수 있는 키들을 후보키라고 합니다.

2. 기본키 (Primary Key)

* 후보키 중에서 선택한 주키(Main Key)

* 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성

* Null 값을 가질 수 없습니다. (개체 무결성의 첫번째 조건)

* 기본키로 정의된 속성에는 동일한 값이 중복되어 저장될 수 없습니다.(개체 무결성의 두번째 조건)

ex) <학생> 릴레이션에는 '학번'이나 '주민번호'가 기본키가 될 수 있고, <수강> 릴레이션에는 '학번'+'과목명'으로 조합해야 기본키가 만들어 질 수 있습니다. 왜냐면 <수강> 릴레이션에서는 '학번' 속성과 '과목명' 속성은 개별적으로 기본키로 사용할 수 없습니다. 다른 튜플들과 구별되지 않기 때문이지요..

ex) <학생> 릴레이션에서 '학번'을 기본키로 정의되면 이미 입력된 '1001'은 다른 튜플의 '학번' 속성 값으로 입력할 수 없습니다.

3. 대체키 (Alternate Key)

* 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키들을 말합니다.

* 보조키라고도 합니다.

ex) <학생> 릴레이션에서 '학번'을 기본키로 정의하면 '주민번호'는 대체키가 됩니다. 

4. 슈퍼키 (Super Key)

* 슈퍼키는 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로서 릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타내지 않습니다. 

* 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족시키지 못합니다.

ex) <학생> 릴레이션에서는 '학번', '주민번호', '학번'+'주민번호', '학번'+'주민번호'+'성명' 등으로 슈퍼키를 구성할 수 있습니다. 또한 여기서 최소성을 만족시키지 못한다는 말은 '학번'+'주민번호'+'성명' 가 슈퍼기인 경우 3개의 속성 조합을 통해 다른 튜플과 구별이 가능하지만, '성명' 단독적으로 슈퍼키를 사용했을 때는 구별이 가능하지 않기 때문에 최소성을 만족시키지 못합니다. 즉 뭉쳤을 경우 유일성이 생기고, 흩어지면 몇몇 속성들은 독단적으로 유일성있는 키로 사용할 수 없습니다. 이것을 최소성을 만족하지 못한다고 합니다.


5. 외래키 (Foreign Key)

* 관계(Relation)를 맺고 있는 릴레이션 R1, R2에서 릴레이션 R1이 참조하고 있는 릴레이션 R2의 기본키와 같은 R1 릴레이션의 속성

* 외래키는 참조되는 릴레이션의 기본키와 대응되어 릴레이션 간에 참조 관계를 표현하는데 중요한 도구로 사용됩니다.

* 외래키로 지정되면 참조 테이블의 기본키에 없는 값은 입력할 수 없습니다. (참조 무결성 조건)

ex) <수강> 릴레이션이 <학생> 릴레이션을 참조하고 있으므로 <학생> 릴레이션의 '학번'은 기본키이고, <수강> 릴레이션의 '학번'은 외래키입니다.

즉 각 릴레이션의 입장에서 속성은 기본키가 되기도하고, 외래키가 되기도 합니다.

ex) <수강> 릴레이션의 '학번'에는 <학생> 릴레이션의 '학번'에 없는 값은 입력할 수 없습니다.

** NULL 값 ???? **

-> 데이터베이스에서 아직 알려지지 않았거나, 모르는 값으로서 "해당 없음" 등의 이유로 정보 부재를 나타내기 위해 사용하는, 이론적으로 아무것도 없는 특수한 데이터를 뜻합니다.


## 4. 자료구조, 알고리즘

### 벡터(배열), 리스트 차이

```
- 배열의 특징 : 같은 자료형을 가진 변수를 하나로 나타낸것
- 연속된 메모리 공간으로 이루어짐, 인덱스와 정적표현, 지역성을 가지고 있다.
- 배열의 장점 : 인덱스를 통해 검색이 용이, 연속적이므로 메모리

- 배열의 단점 : 데이터를 삭제하더라도 배열은 연속해야되므로 공간이 남음, 메모리 낭비
- 정적이므로 배열의 크기를 컴파일 이전에 정해주어야한다. 또한, 컴파일 이후 배열의 크기를 변동 할 수 없다. 
```
```
- 리스트의 특징 : 순서가 있는 데이터의 집합, 불연속적으로 메모리 공간 차지, 동적 표현, 포인터를 통한 접근

- 리스트의 장점 : 포인터를 통해서 다음 데이터의 위치를 가리키고 있어 삽입, 삭제가 용이하다.
- 동적이므로 크기가 정해져있지않다, 메모리 재사용 편리하다, 불연속적이므로 메모리 관리의 편리

- 리스트의 단점 : 검색성능이 좋지않다. 포인터를 통해 다음 데이터를 가리키므로 추가적인 메모리 공간 발생
``` 
- 즉, 자바 ArrayList와 배열 Array 차이점을 큰 차이점을 말하자면 다음과 같다.

1. 배열은 List와 다르게 크기를 지정해야한다.

2. 객체를 일반 배열에 넣을 때는 인덱스를 지정해야한다.

3. 배열의 내부값을 이용할 때는 index 문법을 이용해야한다.

- 정리
```
- 배열 : 데이터 크기가 정해져있고, 추가적인 삽입, 삭제가 일어나지않으며 검색을 필요할 때 유리
- 리스트: 데이터의 크기가 정해져있지않고, 삽입, 삭제가 많이 일어나며, 검색이 적은 경우 유리
```

### 맵과 해쉬맵/ map , unordered_map 차이

STL 컨테이너 중 map은 말씀하신 대로 바이너리 서치 트리를 이용합니다.
(일반 binary tree가 아니라, binary search tree 입니다) 구현된 STL제품은 대부분 red-black트리를 이용하고 있습니다.

BST는 평균 탐색 시간이 O(log n)이 되는데, 이는 대부분의 경우 납득할 만한 성능을 보여주지만, 평균 탐색시간을 O(1), 즉 상수시간 안에 탐색을 해내고 싶을 때는 해쉬 테이블을 사용하게 되죠.

해쉬 테이블은 어떤 데이터를 사용하여 해슁 키를 생성합니다. 이를테면 "123456"이라는 문자열의 해슁 키로 123456이라는 정수를 생성하는 식이죠. 해싱 키 생성에는 여러가지 방법을 고려할 수 있습니다. 이를테면, 데이터를 구성하는 모든 자료를 각각의 바이트 별로 더하는 방법도 고려할 수 있고, 자릿수에 가중치를 두어서 더하는 방법도 있을 수 있습니다. 이로서 "근사적으로" 키와 자료 사이에 1:1 대응이 이루어지도록 해슁 키를 생성하고, 이 해슁 키를 배열의 인덱스로 사용하여 자료에 접근합니다. 단, 잘 만들어진 해슁 키는 랜덤 분포가 되므로, 해슁키를 배열의 사이즈로 (대개는 예상되는 자료 양의 2배에 가까운 소수) 나눈 나머지를 배열의 인덱스로 사용합니다.
배열의 접근은 당연히 상수 시간이 걸리므로, 해쉬 테이블 접근은 O(1)의 시간 복잡도가 나타나게 됩니다.

단, 이때 키를 배열의 사이즈로 나눈 나머지가 겹치는 경우가 발생 할 수 있는데, (배열의 사이즈로 소수를 사용하는 이유는 이러한 경우를 최소화하기 위해서입니다) 이런 경우에는 빈 영역을 찾아서 자료를 저장해야 합니다. 이를 해결하는 방법에는 선형 탐색, 2차 탐색 등이 있을 수 있습니다. 선형 탐색의 경우는 blob이 생성되는 문제가 있고, (즉, 한번 충돌이 일어난 영역 근방에서는 계속 충돌이 일어나게 되어 그 근처에 자료가 몰리게 되는 현상), 2차 탐색에서는 그런 문제가 다소 줄어들게 됩니다.

따라서 해쉬테이블의 성능을 좌우하는 것은 해슁 키를 어떻게 적절하게 생성하느냐 하는 것입니다. 해슁 키의 분포 상태가 랜덤에 가까울 수록 성능이 좋아지는 것이죠. 해쉬 테이블이 아직 STL에 포함되지 않은 것은, STL은 그 규정에서 수행 성능을 보장하도록 되어 있습니다. 이를테면, map, set 등의 컨테이너는 삽입, 삭제, 탐색이 모두 O(log n)을 보장하도록 규정되어 있으며, list등의 컨테이너는 지정된 위치의 삽입과 삭제는 모두 O(1)을 보장하고, 탐색, 임의원소 접근은 O(n)을 보장하도록 되어 있죠. vector 컨테이너는 삽인과 삭제, 탐색 모두 O(n)을 보장하되, 임의원소에의 접근은 O(1)을 보장합니다.


### 큐, 스택차이

- 스택이란 무엇인가?
 
객체들의 집합소로써, 데이터를 기록하는 구조라고 보면 된다.

하지만 접근 방법에 제한을 두고 있다.

접근 방법은 LIFO(Last Input First Out) 라고 부르며, 마지막에 넣은 요소가 먼저 나온다는 의미이다.

아래가 막혀있고 위가 뚫린 형태로써, 차곡차곡 쌓는 구조이다.

이러한 구조이기에, 마지막에 삽입한 요소는 가장 처음으로 삭제할 수 있다.

스택에서 삽입은 PUSH, 삭제는 POP 이라는 용어로 사용하고


- 큐는 무엇인가?
 
큐는 단순히 스택의 반대 개념을 갖는다.

접근 방법은 FIFO (First Input First Out) 라고 불리며, 먼저 들어간 데이터가 먼저 나오는 구조이다.

우리가 흔히 접할 수 있는 순서대로 처리하는 형태이다.

물건을 구매하기 위해, 줄을 선 순서대로 살 수 있는 그러한 구조이다.

이러한 구조이기에, 마지막에 삽입한 요소를 삭제하기 위해서는 앞에 요소들이 전부 삭제되어야한다.

주로 순서를 보장하기 위한 처리가 필요할 때 사용된다.

큐에 저장된 요소들은 순서대로 존재하고, 가장 앞에 있을수록, 오래 기다리고 있다는 것을 의미한다.

예를 들어, CPU는 하나의 태스트가 처리가 완료되어야 다음 태스크를 처리함으로써, 실행 순서대로 처리하게 된다.


퀵소트 설명, 코드 짜보기 O(nlogn), 최악 O(n^2)

- 해당 사이트 [참조](https://blockdmask.tistory.com/177) 하였습니다.

- 퀵 정렬은 기준점(pivot)을 정하고 앞(left)와 뒤(right)를 비교하면서 정렬을 하는 알고리즘입니다.

* 과정
 * 리스트에서 임의의 원소를 고릅니다. 그것을 pivot이라 합니다. (일반적으로 가운데 원소를 고릅니다.)
 * pivot의 앞에는 pivot 보다 작은 원소들로, pivot의 뒤에는 pivot 보다 큰 원소들이 오도록 교환해 줍니다. (divided)
 * divided 된 두 개의 작은 리스트에 대해 Recursive 하게 위의 과정을 반복합니다.
 * Recursive의 종료조건은 리스트의 크기가 0 입니다.


- 장점: 수행속도가 빠른 정렬 알고리즘이다.

- 단점: 중심값이 같을 경우에는 배열의 순서가 파괴 될 수도 있으며 안정성이 없다는 점이다. 


``` c++

//퀵소트 
 
#include<iostream>
using namespace std;
 
void swap(int *arr,int a, int b)
{
    int tmp = arr[a];
    arr[a] = arr[b];
    arr[b] = tmp;
}
 
void QuickSort(int *arr, int start, int end)
{
    int pivot = arr[start];
    int left = start+1;
    int right = end;
 
    while(left <= right)
    {
 
        while(arr[left] < pivot){ left++; } //pivot보다 작은 경우는 건너뛰고 크거나 같은경우 멈춤
        while(arr[right] > pivot) { right--; } //pivot보다 큰 경우는 건너뛰고 작거나 같은경우 멈춤
 
        if(left <= right){ swap(arr, left, right); }
    }
 
 
    if(start < end) 
    {  //1개로 쪼개질때 까지
        swap(arr, start, right);   //pivot값과 arr[right] 값 swap
 
        QuickSort(arr, start, right-1);  //앞 부분
        QuickSort(arr, right+1, end);    //뒷 부분
    }
 
    return;
}
 
void Printout(int *arr, int len)
{

    //출력
    for(int i=0; i<len ; i++)
    {
        cout << "[" << arr[i] << "]";
    }
    cout << endl;
}
 
 
int main(void){
    int arr[7] = {5,3,6,7,1,2,4};

    //범위 넣기 0~6
    QuickSort(arr, 0, 6);
    Printout(arr, 7);
 
    return 0;
}

```

## 5. 언어 

### C, C++

- [ C++ readme에 정리](https://github.com/heonilp/study/blob/master/cpp%20study/README.md)

- C/ C++ 실행 방식, 소스 파일, 컴파일, 링크 ,링커, 실행파일

1. 소스 파일(source file)의 작성

2. 선행처리기(preprocessor)에 의한 선행처리

3. 컴파일러(compiler)에 의한 컴파일

4. 링커(linker)에 의한 링크

5. 실행 파일(executable file)의 생성


###  C++ 캐스팅 4가지 설명

- 여기가 엄청 정리가 잘되있어서 [참고](https://ju3un.github.io/c++-type-casting/) 하였습니다.
- static_cast, reinterpret_cast, const_cast, dynamic_cast 캐스팅 4종류에 정리.

``` C++
int i = 0;
char ch1 = i;       // 묵시적 형 변환(Implicit Cast)
char ch2 = (char)i; // 명시적 형 변환(Explicit Cast)
```

1. static_cast

- 가장 보편적으로 사용되는, 논리적으로 변환 가능한 타입을 변환하는 연산자
- 컴파일(Compile) 시점에 발생
- 묵시적 형 변환(Implicit Cast)과 같은 맥락

- Q. 묵시적 형 변환은 문법적인 키워드가 존재하지 않는데, static_cast이 묵시적 형 변환과 같은 의미라니?
 * 컴파일러가 값을 변환하기 위해 기계어 코드를 만들어 내는 컴파일 시점에 형 변환이 일어나는 관점 에서 같은 맥락

- Q. 그렇다면 static_cast(정적 캐스팅)과 묵시적 형 변환과의 차이는?
```
"상속 관계에 있는 포인터끼리 변환이 가능하다"는 점이다.
그러나, 다운캐스트(Downcast)의 경우 Unsafe 하다. (Unsafe Downcasting)
```
- cf. new_type으로 void* 형이 올 수 있지만 return 값이 없다.


2. reinterpret_cast

- 임의의 포인터끼리 변환 허용 (연관성이 없는 포인터 타입의 형 변환 가능) (static_cast와의 차이점)
- 강제 형 변환으로 문법적으로 변환을 허용하는 것이지, 논리적으로 안전한 타입 연산자는 아님
- expression에 해당하는 것을 new_type으로 비트 단위로 강제 형 변환
- ex) 주로 정수형 -> 포인터 또는 포인터 -> 정수형 변환하는 작업에 주로 사용함

3. const_cast

- 포인터 타입, 참조형에 대해서만 사용되며 동일한 타입에 대해서만 허용함
- const 속성이나 volatile 속성을 잠깐 제거할 때 사용

4. dynamic_cast

- RTTI(Runtime Type Information)
```
C++ 컴파일러 내에 포함되어 있는 기능으로, 객체의 유형을 실행 시에 결정할 수 있도록 허용하는 것을 의미한다.
다른 말로는 실행 중에 타입의 정보를 가지고 온다는 의미로 표현할 수도 있다.

메모리 상주 객체에 유형 정보를 추가하여, 실행 시스템은 객체의 캐스트(=형 변환)가 유효한 지 여부를 확실히 하기 위해 특정 객체의 유형을 결정할 수 있다.

RTTI는 객체를 동적으로 변화시킬 수 있는 Polymorphism 능력이라고 이해하면 된다.
타입 캐스팅에서 이 용어를 다룬 이유는, 바로 dynamic_cast 연산자가 이 요소 중 하나이기 때문이다.
```

- 주로 다운 캐스팅으로 사용되는 연산자 (부모 클래스 포인터에서 -> 자식 클래스 포인터로 다운캐스팅)
- 다른 캐스트와 달리 런타임 시간에 다운 캐스팅이 가능한지 능동적으로 판단하기 때문에 런타임 비용이 높음.-
- 형 변환 성공 시 : 변환된 값 return
- 형 변환 실패 시 : 널 포인터(null pointer) 또는 예외(Exception) return

### JAVA

## 1. JAVA의 실행 과정 설명해주세요.

<div>
<img src="https://github.com/heonilp/study/blob/master/JAVA%20study/%EC%89%BD%EA%B2%8C%20%EB%B0%B0%EC%9A%B0%EB%8A%94%20%EC%9E%90%EB%B0%941/1.%20Java%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%86%8C%EA%B0%9C%20%26%20Java%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EA%B5%AC%EC%84%B1/pc/javarun.jpg" width="30%"></img>
</div>

- java 파일의 형태로 소스 코드를 작성하면, 컴파일 과정을 거쳐
- JVM(Java Virtual Machine, 자바 가상 머신)이 알아들을 수 있는 class 파일로 변환됩니다.
- 이클립스에서는 자바 파일을 저장할 때 컴파일을 하여 class 파일로 저장합니다.
- 이클립스에서 실행 버튼을 누르게 되면 JVM에서 class 파일을 읽어들입니다.
- JVM은 class 파일을 읽고서 그대로 컴퓨터를 동작시키게 됩니다.

## 2. JVM(JAVA Virtual Machine) 설명해주세요
### 개념
- 자바 가상 머신(JVM) 은 자바 바이트 코드(.class 파일)를 OS 에 특화된 코드로 변환(인터프리터와 JIT 컴파일러)하여 실행합니다. 
- 따라서 자바 가상머신은 자바와 달리 플랫폼 종속적이며, JVM 에 의해 자바가 플랫폼 독립적이게 됩니다.

```
즉, JVM은 운영체제(OS)와 JAVA 언어간의 중개자 역할을 하면서 어떤 운영체제를 사용하더라도
같은 JAVA 코드를 이용해서 실행 할 수 있도록 도와준다.
또한 가장 중요한 메모리 관리를 담당하므로써 개발자가 일일히 객체의 할당된 메모리를 해제하지 않아도 Garbage Collector가 Garbage Collection을 수행한다.
```

### 전체적인 흐름

- 자바 소스파일을 Java Complier 가 클래스 파일로 변환하고, Class Loader 가 Runtime Data Area 에 클래스 파일을 적재 시킵니다.
- Execution Engine 이 자바 메모리에 적재된 클래스 들을 기계어로 변환해 명령어 단위로 실행하고
- Garbage Collector 는 Heap 영역에 적재된 객체들 중에서 참조되지 않은 객체를 제거합니다.

### JVM 구조

JVM 은 크게 4가지로 구분됩니다.

<div>
<img src="https://github.com/heonilp/study/blob/master/JAVA%20study/%EC%89%BD%EA%B2%8C%20%EB%B0%B0%EC%9A%B0%EB%8A%94%20%EC%9E%90%EB%B0%941/1.%20Java%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%86%8C%EA%B0%9C%20%26%20Java%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EA%B5%AC%EC%84%B1/pc/4.png" width="60%"></img>
</div>

- Class Loader
- Execution Engine
- **Runtime Data Area** = memory
- Native

- 클래스 로더(Class Loader) : 로딩, 링크, 초기화 순서로 진행됩니다. 
```
클래스 로더라는 이름 그대로 클래스 파일을 적재(Runtime Data Area) 하는 역할을 합니다.
```

-Execution Engine
```
Execution Engine 은 Class Loader에 의해 Runtime Data Area 에 적재된 클래스(바이트 코드)들을
컴퓨터가 이해할 수 있는 기계어로 변경해 명령어 단위로 실행하는 역할을 합니다.
이때 명령어를 하나씩 실행하는 인터프리터 방식이 있고, 바이트 코드를 네이티브 코드로 변환하는 JIT Compiler 방식이 있습니다.
```
- Interpreter
```
Execution Engine(실행 엔진)은 바이트코드를 명령어 단위 별로 읽어와서 실행한다.
하지만 인터프리터의 단점을 그대로 가지고 있기 때문에 한 줄 씩 수행하고, 그 때문에 속도가 느리다는 단점을 가지고 있다.
```
- JIT Compiler
```
JIT compiler는 이러한 인터프리터의 단점을 고치기 위해서 도입된 컴파일러이다. 
적절한 시간에 전체 바이트 코드를 네이티브 코드로 변경해서 Execution Engine이 네이티브로 컴파일된 코드를 실행하는 방식으로 되어 성능을 높일 수 있다.
```

그리고 Runtime Data Area 는 5가지로 구성됩니다.


<div>
<img src="https://github.com/heonilp/study/blob/master/JAVA%20study/%EC%89%BD%EA%B2%8C%20%EB%B0%B0%EC%9A%B0%EB%8A%94%20%EC%9E%90%EB%B0%941/1.%20Java%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%86%8C%EA%B0%9C%20%26%20Java%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EA%B5%AC%EC%84%B1/pc/5.png" width="70%"></img>
</div>


- Method Area (= Class Area, Code Area, Static Area)
- Heap Area
- Stack Area
- PC registers
- Native Method stack

```
메서드 영역(Method Area) : 클래스 멤버 변수 이름, 데이터 타입, 리턴타입, 상수풀, static 변수 등이 저장됩니다. 
클래스 수준의 정보가 저장됩니다. 여기에 저장된 정보들은 공유 됩니다.
```

```
힙 영역(Heap Area) : new 연산자로 생성된 객체와 배열이 저장됩니다. ex) Event event = new Event(); 로 생성한 event 는 
스택영역에 저장되며 new 연산자로 생성한 Event() 가 힙 영역에 저장됩니다. event 변수는 힙 영역의 주소값을 가지고 있습니다. 
여기에 저장된 정보들은 공유 됩니다.
```
```
스택 영역(Stack Area) : 스레드가 생성될 때 마다 생성되는 영역으로, 대표적으로 지역변수가 여기에 저장됩니다. 
메서드를 호출할 때마다 스택이 개별적으로 생성됩니다.
따라서 동시성(concurrency) 문제를 해결하기 위해서 메서드에 동기화 블럭(synchronized) 를 지정하는데,
동기화 블럭 없이 동시성 문제를 해결하는 방법중 하나가, 지역 변수를 이용하는 방법이 있습니다.

```
```
PC Register : 쓰레드가 생성될 때마다 생성되는 영역으로 Program Counter 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장하고 있는 영역입니다. 
이것을 이용해서 쓰레드를 돌아가면서 수행할 수 있게 합니다. 
쓰레드가 생성되었을때 메서드와 힙 영역은 모든 스레드가 공유하며, PC Register, 스택 영역, Native Stack Area 는 공유되지 않습니다.
즉, 현재 수행 중인 JVM의 명령 주소를 갖는 부분으로 메모리에 데이터 전달 전에 저장 한다
```
```
Native Method Stack : 자바 언어 이외의 언어로 작성된 코드를 저장하는 메모리 영역입니다.
즉, Java가 아닌 언어로 작성된 네이티브 코드들을 저장하기 위한 Stack이다. JNI, JNA 모두 이 부분을 이용하여 C/C++ 코드를 수행하기 위해 필요하다. 
또한 네이티브 메소드의 매개변수, 지역변수 등을 바이트 코드로 저장한다.
```

## 3. GC(Garbage collection) 설명해주세요
- [🐥엘리의 GC - 가비지 컬렉션 강의 추천](https://www.youtube.com/watch?v=Fe3TVCEJhzo&t=3s)
<div>
<img src="https://github.com/heonilp/study/blob/master/JAVA%20study/%EC%89%BD%EA%B2%8C%20%EB%B0%B0%EC%9A%B0%EB%8A%94%20%EC%9E%90%EB%B0%941/1.%20Java%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%86%8C%EA%B0%9C%20%26%20Java%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EA%B5%AC%EC%84%B1/pc/6.png" width="50%"></img>
</div>

- 한마디로 정의: JVM에서 힙 영역에서 사용하지 않는 객체를 삭제하는 프로세스를 말한다.


<div>
<img src="https://github.com/heonilp/study/blob/master/JAVA%20study/%EC%89%BD%EA%B2%8C%20%EB%B0%B0%EC%9A%B0%EB%8A%94%20%EC%9E%90%EB%B0%941/1.%20Java%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%86%8C%EA%B0%9C%20%26%20Java%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EA%B5%AC%EC%84%B1/pc/7.png" width="50%"></img>
</div>

- 어떤 객체에 유효한 참조가 존재한다면 Reachable, 그렇지 않으면 Unreachable이라고한다.
1. Stack 영역의 데이터들
2. method 영역의 static 데이터들
3. JNI에 의해 생성된 객체들

### java의 가비지 컬렉션 처리 방법
* java의 가비지 컬렉션(Garbage Collection) 처리 방법
  * GC 작업을 수행하는 가비지 콜렉터가 하는 일
      1. 메모리 할당
      2. 사용 중인 메모리 인식
      3. 미사용 메모리 인식
  * Stop the World
    * 자바 애플리케이션은 GC 실행 시 GC 실행 스레드를 제외한 모든 스레드를 멈추고, GC 완료 후 다시 스레드들을 실행 상태로 변경
    * Stop the World는 모든 애플리케이션 스레드의 작업이 멈추는 상태
    * 어떤 GC 알고리즘을 사용하더라도, Stop the World는 불가피하며 최소화하기 위해 GC 튜닝을 진행

 
#### Mark and Sweep, 그리고 Compact
- Mark : GC는 GC Root로 부터 모든 변수를 스캔하면서 각각 어떤 객체를 참조하고 있는지 찾아서 마킹한다.
- Sweep : Unreachable 객체들을 Heap에서 제거한다.
- 그리고 Compact Sweep 후에 분산된 객체들을 Heap의 시작 주소로 모아 메모리가 할당된 부분과 그렇지 않는 부분으로 나눈다. 
- 메모리 단편화를 막는다.


#### 힙의 구조

<div>
<img src="https://github.com/heonilp/study/blob/master/JAVA%20study/%EC%89%BD%EA%B2%8C%20%EB%B0%B0%EC%9A%B0%EB%8A%94%20%EC%9E%90%EB%B0%941/1.%20Java%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%86%8C%EA%B0%9C%20%26%20Java%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EA%B5%AC%EC%84%B1/pc/jvm8.png" width="70%"></img>
</div>


  * 가비지 콜렉터가 들르는 메모리 영역은 Young 영역에 포함되는 Eden, Survivor1, Survivor2와 Old 영역 (Permanent 영역은 Java 1.8 부터 제거)
  * Young 영역에 있는 객체는 각 하위 영역이 가득 차면 Miner GC가 동작하여 더이상 참조되지 않는 객체 제거
  * Old 영역에 있는 객체는 영역이 가득 차면 Major GC(Full GC)가 동작하여 더이상 참조되지 않는 객체 제거

  * 동작 과정
    * 객체를 최초 생성하면 Young 영역 중 Eden 영역에 위치
    * Eden 영역에서 Miner GC 발생 시, 참조 중인 객체라면 Survivor1로 이동
    * Survivor1에서 Miner GC 발생 시, 참조 중인 객체라면 Survivor2로 이동
    * Survivor2에서 Miner GC 발생 시, 참조 중인 객체라면 다시 Survivor1 영역으로 이동 (Survivor1 <--> 2 반복)
    * Survivor 영역이 가득 차거나 Young 영역에서 오래 살아남은 객체는 Old 영역으로 이동
      * '오래'의 기준은 객체마다 age bit라는 것을 가지고 있는데 이는 Miner GC에서 살아남은 횟수를 기록하는 값
    * Old 영역에 있는 객체는 Major GC가 발생했을 때 참조 여부에 따라 공간이 유지되거나 제거

#### java9의 default GC

##### G1GC
- Garbage First Garbage Collector
- Java 9, 10의 default GC
- Java 7, 8의 default GC는 ParallelGC
  - 활성화 옵션 ```-XX:+UseG1GC```
- 큰 메모리를 가진 멀티 프로세스 시스템에서 사용하기 위해 개발된 GC
- Stop the World 최소화 목적(실시간 GC는 불가능)
- 통계를 계산하면서 GC 작업량 조절
- G1을 사용하면 좋은 경우
  - Java heap의 50% 이상이 라이브 데이터일 때
  - GC가 너무 오래 걸릴 때(0.5초 ~ 1초)

##### G1GC 특징
- 다른 GC와 다르게 전체 힙 공간을 체스판처럼 여러 영역으로 나누어 관리
  - GC 발생 시, 전체 힙이 아닌 일부 영역에서만 GC 수행
  - 따라서 큰 힙 크기를 가질 경우 유리
- 영역의 참조를 관리할 목적으로 remember set을 만들어 사용(set은 전체 힙의 5% 미만 크기)

<div>
<img src="https://github.com/heonilp/study/blob/master/JAVA%20study/%EC%89%BD%EA%B2%8C%20%EB%B0%B0%EC%9A%B0%EB%8A%94%20%EC%9E%90%EB%B0%941/1.%20Java%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%86%8C%EA%B0%9C%20%26%20Java%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EA%B5%AC%EC%84%B1/pc/9.png" width="70%"></img>
</div>

- **회색** : 빈 영역 / **연두색** : Eden 영역 / **노란색 S** : Survivor 영역 / **파란색** : Old 영역(파란색 H는 크기가 커서 여러 영역 차지하는 객체)
- Young과 Old 영역의 구분 없이 사용
- 비어있는 영역에 새로 할당한 객체 위치
- STW 시간 최소화를 위해 병렬 GC 작업 처리(각 스레드가 자신만의 영역을 잡고 작업)

##### G1GC 동작 과정
- Young 영역(Eden, Survivor)에서는 Young GC가 수행되며 Eden, Survivor 영역 이동
  - 옮기면서 비워진 영역은 사용 가능한 빈 영역으로 되돌림
- Full GC 수행 단계
  - Initial Mark -> Root Region Scan -> Concurrent Mark -> Remark -> Cleanup -> Copy
  - Initial Mark
    - Old 지역에 존재하는 객체가 참조하는 Survivor 영역 탐색
    - STW 발생
  - Root Region Scan
    - 이전 단계에서 찾은 영역에 대한 GC 대상 객체 스캔
  - Concurrent Mark
    - 전체 힙 영역 스캔
    - GC 대상 객체가 없는 영역은 이후 단계에서 제외
  - Remark
    - STW가 발생하며 최종으로 GC 대상에서 제외할 객체 식별
  - Cleanup
    - STW가 발생하며 제거할 객체가 가장 많은 지역에서 GC 수행
    - 완료 후, 완전히 비워진 영역을 재사용하기 위해 Freelist에 추가
  - Copy
    - GC 대상이었지만 Cleanup 단계에서 완전히 비워지지 않은 지역의 남은 객체를 새로운 영역에 복사하여 조각 모음(Compaction) 작업 수행

##### G1GC vs ParallelGC
- ParallelGC는 Old Generation 영역에서만 Full GC(공간 재확보 및 조각 모음) 수행
- G1은 더 짧은 주기의 Full GC 작업을 수행하여 전체적인 처리량이 줄어드는 대신 일시 정지 시간을 크게 단축

##### G1GC vs CMS
- CMS는 Old Generation의 조각 모음(Compaction)을 하지 않으므로 Full GC 시간이 길어지는 문제 발생
- CMS는 Old 영역 사용량이 특정 기준치 값 넘어가면 수행
- G1GC는 Old 영역에서 GC 발생 시, 힙 사용량이 특정 기준치 값을 넘어가면 실행


### final 키워드에 대해서 설명해주세요.

* **final 키워드**
  * 개념: 변수나 메서드 또는 클래스가 '변경 불가능'하도록 만든다.
  * 원시(Primitive) 변수에 적용 시
    * 해당 변수의 값은 변경이 불가능하다.
  * 참조(Reference) 변수에 적용 시
    * 참조 변수가 힙(heap) 내의 다른 객체를 가리키도록 변경할 수 없다.
  * 메서드에 적용 시
    * 해당 메서드를 오버라이드할 수 없다.
  * 클래스에 적용 시
    * 해당 클래스의 하위 클래스를 정의할 수 없다.

* **finally 키워드**
  * 개념: try/catch 블록이 종료될 때 항상 실행될 코드 블록을 정의하기 위해 사용한다.
  * finally는 선택적으로 try 혹은 catch 블록 뒤에 정의할 때 사용한다.
  * finally 블록은 예외가 발생하더라도 항상 실행된다.
    * 단, JVM이 try 블록 실행 중에 종료되는 경우는 제외한다.
  * finally 블록은 종종 뒷마무리 코드를 작성하는 데 사용된다.
  * finally 블록은 try와 catch 블록 다음과, 통제권이 이전으로 다시 돌아가기 전 사이에 실행된다.

* **finalize() 메서드**
  * 개념: 쓰레기 수집기(GC, Garbage Collector)가 더 이상의 참조가 존재하지 않는 객체를 메모리에서 삭제하겠다고 결정하는 순간 호출된다.
  * Object 클래스의 finalize() 메서드를 오버라이드해서 맞춤별 GC를 정의할 수 있다.
    * `protected void finalize() throws Throwable { // 파일 닫기, 자원 반환 등등 }

### 깊은복사 얇은 복사

- [참조] (https://shyunku.tistory.com/38) 하였습니다.


1. 얕은 복사(Shallow Copy)
- 정의
```
객체를 복사할 때, 해당 객체만 복사하여 새 객체를 생성한다.
복사된 객체의 인스턴스 변수는 원본 객체의 인스턴스 변수와 같은 메모리 주소를 참조한다.
따라서, 해당 메모리 주소의 값이 변경되면 원본 객체 및 복사 객체의 인스턴스 변수 값은 같이 변경된다.
```
2. 깊은 복사(Deep Copy)
- 정의
```
객체를 복사 할 때, 해당 객체와 인스턴스 변수까지 복사하는 방식.
전부를 복사하여 새 주소에 담기 때문에 참조를 공유하지 않는다
```
- 보통 자바에서 객체를 복사/복제(clone)을 한다고 하면, 다음과 같이 쓴다.
- 얕은 복사는 다음과 같다.

``` java 
CustomClass object = new CustomClass();
CustomClass copied = object;
//객체 복사도 얕은 복사에 해당한다.

ArrayList<String> classList = new ArrayList<>();
classList.add("a");
classList.add("b");
classList.add("c");
classList.add("d");
 
ArrayList<CustomClass> copiedList = new ArrayList<>();
 
copiedList = classList;		//복사? 하지만 깊은 복사가 되지않는다.
```

- 깊은 복사를 사용하는 방식은 다음과 같다.

``` java 
public class CustomClass implements Cloneable{
	...
    @Override
    public Object clone(){
    	//CloneNotSupportedException 처리
    	return super.clone();
    }
}
 
CustomClass object = new CustomClass();
CustomClass copied = (CustomClass) object.clone();

//우선 해당 객체의 클래스에 Cloneable 인터페이스를 implement해주고 
//unimplemented function인 clone()를 선언해주면 위와 같이 사용할 수 있다.

//리스트 같은경우는
copiedList.addAll(classList);

```


###  JAVA의 public static void 선언 이유를 면접에서 많이 물어봅니다.

``` java
 public static void main(String[] args){...}
```
- public static void 는 java에서의 main() 관례이다. 위와 같은 시그니처를 가진 메소드가 없으면 실행되지 않는다.
- JVM은 인스턴스가 없는 클래스의 main()을 호출해야하기 때문에 static이어야 한다.

#### Java의 Main 
- Java는 Main에서 시작해서 Main에서 끝난다
- Main은 여러 클래스와 연결될 수 있는 중심부의 역할이다.
 
#### 매인의 public
- Main을 실행하는데 있어, Main에서는 다른 클래스의 메소드 등을 호출해야하는데, 막상 Main 자체가 다른 곳에서 접근을 허용하지 않는다면 문제가 생길 수 밖에 없어 Main의 접근제한자를 public으로 선언한 것입니다.
 
#### 메인의 static
- static은 프로그램이 시작하면 따로 인스턴스화 하지 않아도 method 영역 메모리에 호출되어 진다. 이렇게 호출되어진 것들은 프로그램이 종료되기 까지 유지된다.
- 즉, 프로그램의 시작과 끝을 함께하는 Main 메소드는 프로그램이 종료되는 시점까지 유지해야하기 때문에 static으로 선언된 것이다.
 
#### 메인의 void
- Main 메소드는 프로그램이 종료되는 시점까지 유지가 된다. 즉, 만약 반환 타입이 선언되어 있다면 프로그램이 종료될 때 어떤 값을 반환하겠다라는 것인데, 이는 우리가 추구하는 목적과는 상관없는 로직이다.
- 우리는 프로그램을 사용할 때 프로그램이 구동되는 그 시점에서만 메시지를 주고 받으므로, 프로그램이 종료되는 시점에서 반환되는 값은 전혀 의미가 없는 값이다.


## 공통

### 힙과 스택 차이

메모리 구조

프로그램이 실행되기 위해서는 먼저 프로그램이 메모리에 로드(load)되어야 합니다.

또한, 프로그램에서 사용되는 변수들을 저장할 메모리도 필요합니다.

따라서 컴퓨터의 운영체제는 프로그램의 실행을 위해 다양한 메모리 공간을 제공하고 있습니다.

프로그램이 운영체제로부터 할당받는 대표적인 메모리 공간은 4가지 있습니다.

코드(code) 영역

데이터(data) 영역

스택(stack) 영역

힙(heap) 영역

My Image

코드(code) 영역
메모리의 코드(code) 영역은 실행할 프로그램의 코드가 저장되는 영역으로 텍스트(code) 영역이라고도 부릅니다.

CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 됩니다.

데이터(data) 영역
메모리의 데이터(data) 영역은 프로그램의 전역 변수와 정적(static) 변수가 저장되는 영역입니다.

데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸합니다.

스택(stack) 영역
메모리의 스택(stack) 영역은 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역입니다.

스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸합니다.

이렇게 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임(stack frame)이라고 합니다.

스택 영역은 푸시(push) 동작으로 데이터를 저장하고, 팝(pop) 동작으로 데이터를 인출합니다.

이러한 스택은 후입선출(LIFO, Last-In First-Out) 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 가장 먼저 인출됩니다.

스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당됩니다.

힙(heap) 영역
메모리의 힙(heap) 영역은 사용자가 직접 관리할 수 있는 ‘그리고 해야만 하는’ 메모리 영역입니다.

힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됩니다.

힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당됩니다.

스택과 힙의 장단점
스택
매우 빠른 액세스

변수를 명시 적으로 할당 해제 할 필요가 없습니다.

공간은 CPU에 의해 효율적으로 관리되고 메모리는 단편화되지 않습니다.

지역 변수 만

스택 크기 제한 (OS에 따라 다름)

변수의 크기를 조정할 수 없습니다.

힙
변수는 전역 적으로 액세스 할 수 있습니다.

메모리 크기 제한 없음

(상대적으로) 느린 액세스

효율적인 공간 사용을 보장하지 못하면 메모리 블록이 할당 된 후 시간이 지남에 따라 메모리가 조각화되어 해제 될 수 있습니다.

메모리를 관리해야합니다 (변수를 할당하고 해제하는 책임이 있습니다)

변수는 C언어 realloc() or 자바 new

### OOP 4가지 특성

- 객체 지향 프로그래밍(영어: Object-Oriented Programming, OOP)은 컴퓨터 프로그래밍의 패러다임의 하나 절차지향(C)언어에서는 각 명령어의 실행 순서를 기반으로 바라 보는 시선이었다.
- 하지만 OOP는 데이터와 이를 처리하는 루틴들을 하나의 **독립된 객체**로 바라 보는 시선이다.
- 이를 통해서 큰 프로젝트에 많이 사용된다. 그 이유는 **재사용성의 증가**이다. 
- 하지만 생성자, 소멸자, 접근제어[Public, Private, Protected] 와 같은 내용은 이러한 오류를 잡아준다. 

1. 추상화(Abstraction)
``` java
어떤 영역에서 필요로 하는 속성이나 행동을 추출하는 작업
사물들의 공통된 특징, 즉 추상적 특징을 파악해 인식의 대상으로 삼는 행위를 말한다.
구체적인 사물들의 공통적인 특징을 파악해서 이를 하나의 개념(집합)으로 다루는 수단을 말한다.
즉, 기본적으로 들어갈 정보들을 생각 할 수있을 것이다. 그리고 구체화 시켜 나가는 것이다.
추상화를 통해서 Class(틀)를 만들어 놓고 상세한 부분들을 채워 나가는 것이다.
```

2. 캡슐화(Encapsulation)
``` java
객체의 내용 중 숨기고 싶은 부분은 외부에서 접근 할 수 없다.
단지 해당 객체내의 함수에 의해서만 접근 가능 하도록 하는 것이다. 이를 통해서 정보 은닉이 가능해진다. 
앞서 말한 접근제어[public, private, protected]와 같은 내용에 의해서 구현 되어진다. 
```

3. 상속(Inheritance)

``` java
Class의 멤버(데이터)와 함수를 다른 Class에 물려주거나, 물려 받는 것을 말한다.

1.코드의 재사용을 증대 시킬 수있다. 같은 기능을 또 구현 할 필요가 없다.
2. 좀 더 폭넓게 사용 가능하다. 상속 받은 함수를 추가적으로 데이터와 함수 내용을 변경 가능.

```
4. 다형성(Polymorphism)
- **역할**과 **구현**으로 세상을 구분
- 역할 = 인터페이스
- 구현 = 인터페이스를 구현한 클래스, 구현 객체

``` java
다형성은 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력이다.
다형성이 상속과 연계되어 동작하면 매우 강력한 힘을 발휘한다.
다형성과 일반화 관계는 코드를 간결하게 할 뿐 아니라 변화에도 유연하게 대처할 수 있게 한다.
다형성에는 오버로딩과 오버라이딩이 있다.
```

### OOP의 5대원칙 (SOLID)

- 클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리

* SRP: 단일 책임 원칙(single responsibility principle)
* OCP: 개방-폐쇄 원칙 (Open/closed principle)
* LSP: 리스코프 치환 원칙 (Liskov substitution principle)
* ISP: 인터페이스 분리 원칙 (Interface segregation principle)
* DIP: 의존관계 역전 원칙 (Dependency inversion principle)

1. **SRP: 단일 책임 원칙**(single responsibility principle)

- 한 클래스는 하나의 책임만 가져야 한다.
```
• 하나의 책임이라는 것은 모호하다.
• 클 수 있고, 작을 수 있다.
• 문맥과 상황에 따라 다르다.
• 중요한 기준은 변경이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것
• 예) UI 변경, 객체의 생성과 사용을 분리
```
2. **OCP: 개방-폐쇄 원칙** (Open/closed principle)

- 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다
```
• 이런 거짓말 같은 말이? 확장을 하려면, 당연히 기존 코드를 변경?
• 다형성을 활용해보자
• 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
```
- 지금까지 배운 역할과 구현의 분리를 생각해보자
``` java 
public class MemberService {
 private MemberRepository memberRepository = new MemoryMemberRepository();
}

public class MemberService {
// private MemberRepository memberRepository = new MemoryMemberRepository();
 private MemberRepository memberRepository = new JdbcMemberRepository();

}
```
- 위 코드의 문제점
```
• MemberService 클라이언트가 구현 클래스를 직접 선택
• MemberRepository m = new MemoryMemberRepository(); //기존 코드
• MemberRepository m = new JdbcMemberRepository(); //변경 코드
• 구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다.
• 분명 다형성을 사용했지만 OCP 원칙을 지킬 수 없다.
```
-  이 문제를 어떻게 해결해야 하나?
 * 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다

3. **LSP: 리스코프 치환 원칙** (Liskov substitution principle)

- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀수 있어야 한다
 ```
 • 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것,
  다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요하다.
 단순히 컴파일에 성공하는 것을 넘어서는 이야기 
 예) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리더라도 앞으로 가야함
```
4. **ISP: 인터페이스 분리 원칙** (Interface segregation principle)

 - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다

 ```
 • 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
 • 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
 • 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음
 • 인터페이스가 명확해지고, 대체 가능성이 높아진다.
```
5. **DIP: 의존관계 역전 원칙** (Dependency inversion principle)

프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.” 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
```
 • 쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
 • 앞에서 이야기한 역할(Role)에 의존하게 해야 한다는 것과 같다. 
   객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다! 
   구현체에 의존하게되면 변경이 아주 어려워진다.
```
 - 그런데 OCP에서 설명한 MemberService는 인터페이스에 의존하지만, 구현 클래스도 동시에 의존한다.

 ```
 • MemberService 클라이언트가 구현 클래스를 직접 선택
 • MemberRepository m = new MemoryMemberRepository();
 • DIP 위반
```

- **정리**
```
• 객체 지향의 핵심은 다형성
• 다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.
• 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
• 다형성 만으로는 OCP, DIP를 지킬 수 없다.
• 뭔가 더 필요하다, 일단 역햘과 구현을 나누자, DI(Dependency Injection, 의존관계, 의존성 주입) 가 필요하다
```

## 1. C, JAVA 언어 차이, 절차지향과 객체지향 차이 설명해주세요.

### java와 c/c++의 차이점
- java와 c/c++의 가장 큰 차이점은 실행 환경이다.
- java에서의 개발: 컴파일 혹은 컴파일 + jar압축
  - 자바는 링크 과정이 없이 컴파일러가 바로 바이트 코드를 생성
- c/c++에서의 개발: 컴파일 + 링크

### java 언어의 장단점
- 장점
  - **운영체제에 독립적이다.**
    - JVM에서 동작하기 때문에, 특정 운영체제에 종속되지 않는다.
  - **객체지향 언어이다.**
    - 객체지향적으로 프로그래밍 하기 위해 여러 언어적 지원을 하고있다. (캡슐화, 상속, 추상화, 다형성 등)
    - 객체지향 패러다임의 특성상 비교적 이해하고 배우기 쉽다.
  - **자동으로 메모리 관리를 해준다.**
    - JVM에서 Garbage Collector라고 불리는 데몬 쓰레드에 의해 GC(Garbage Collection)가 일어난다. GC로 인해 별도의 메모리 관리가 필요 없으며 비지니스 로직에 집중할 수 있다. [(참고)](http://www.jpstory.net/2013/12/15/garbage-collection-in-java/)
  - **오픈소스이다.**
    - *정확히 말하면 OpenJDK가 오픈소스이다. OracleJDK는 사용 목적에 따라서 유료가 될 수 있다.*
      - OracleJDK의 유료화 이슈는 다음을 참고. [(참고)](https://okky.kr/article/490213)
    - 많은 Java 개발자가 존재하고 생태계가 잘 구축되어있다. 덕분에 오픈소스 라이브러리가 풍부하며 잘 활용한다면 짧은 개발 시간 내에 안정적인 애플리케이션을 쉽게 구현할 수 있다.
  - **멀티스레드를 쉽게 구현할 수 있다.**
    - 자바는 스레드 생성 및 제어와 관련된 라이브러리 API를 제공하고 있기 때문에 실행되는 운영체제에 상관없이 멀티 스레드를 쉽게 구현할 수 있다.
  - **동적 로딩(Dynamic Loading)을 지원한다**
    - 애플리케이션이 실행될 때 모든 객체가 생성되지 않고, 각 객체가 필요한 시점에 클래스를 동적 로딩해서 생성한다. 또한 유지보수 시 해당 클래스만 수정하면 되기 때문에 전체 애플리케이션을 다시 컴파일할 필요가 없다. 따라서 유지보수가 쉽고 빠르다.
- 단점
  - **비교적 속도가 느리다.**
    - 자바는 한 번의 컴파일링으로 실행 가능한 기계어가 만들어지지 않고 JVM에 의해 기계어로 번역되고 실행하는 과정을 거치기 때문에 C나 C++의 컴파일 단계에서 만들어지는 완전한 기계어보다는 속도가 느리다. 그러나 하드웨어의 성능 향상과 바이트 코드를 기계어로 변환해주는 JIT 컴파일러 같은 기술 적용으로 JVM의 기능이 향상되어 속도의 격차가 많이 줄어들었다.
  - **예외처리가 불편하다.**
    - 프로그래머 검사가 필요한 예외가 등장한다면 무조건 프로그래머가 선언을 해줘야 한다.


### 객체지향 프로그래밍과 절차지향 프로그래밍의 차이
* 절차지향 프로그래밍
  * 실행하고자 하는 절차를 정하고, 이 절차대로 프로그래밍하는 방법
  * 목적을 달성하기 위한 일의 흐름에 중점을 둔다.
* 객체지향 프로그래밍
  * 실세상의 물체를 객체로 표현하고, 이들 사이의 관계, 상호 작용을 프로그램으로 나타낸다.
  * 객체를 추출하고 객체들의 관계를 결정하고 이들의 상호 작용에 필요한 함수(메서드)와 변수(필드)를 설계 및 구현하다.
  * 객체 지향의 핵심은 연관되어 있는 변수와 메서드를 하나의 그룹으로 묶어서 그룹핑하는 것이다.
  * 사람의 사고와 가장 비슷하게 프로그래밍을 하기 위해서 생성된 기법
  * 하나의 클래스를 바탕으로 서로 다른 상태를 가진 인스턴스를 만들면 서로 다른 행동을 하게 된다. 즉, 하나의 클래스가 여러 개의 인스턴스가 될 수 있다는 점이 객체 지향이 제공하는 가장 기본적인 재활용성이라고 할 수 있다.


#### 객체지향의 장점(강점)
객체를 중심으로 프로그래밍하기 때문에,
- 사람의 관점에서 프로그램을 이해하고 파악하기 쉽다.
- 강한 응집력(Strong Cohesion)과 약한 결합력(Weak Coupling)을 가진다.
- 재사용성, 확장성, 융통성이 높다.

이러한 장점 때문에 디버깅과 유지보수가 용이하고 설계과 분석이 비교적 쉽다.

#### 객체지향의 단점(한계)
- 객체 간의 정보 교환이 모두 메시지 교환을 통해 일어나므로 실행 시스템에 많은 overhead가 발생하게 된다.
  - 처리속도가 상대적으로 느리다.
  - 하지만 하드웨어의 발전으로 이러한 단점은 어느정도 해소되었다.
- 객체가 상태를 갖기 때문에 예상치 못한 부작용이 발생할 수 있다. 변수가 존재하고 이 변수를 통해 객체가 예측할 수 없는 상태를 갖게 되어 애플리케이션 내부에서 버그를 발생시킬 수 있다.
  - 이는 함수형 프로그래밍 등장의 패러다임이다.

### 오버로딩과 오버라이딩의 차이(Overloading vs Overriding)

- 자바에서 다형성을 지원하는 방법으로 메소드 오버로딩(Overloading) 오버라이딩(Overriding)이 있다.

- 오버로딩(Overloading) : 같은 이름의 메소드를 여러 개 가지면서 매개변수의 유형과 개수가 다르도록 하는 기술이다.

- 오버라이딩(Overriding) : 부모 클래스가 가지고 있는 메소드를 자식 클래스가 재정의 해서 사용한다.

- JAVA에서 오버로딩과 오버라이딩 예제입니다.
``` java 
//오버로딩
public class Overloadingtest {

    // test() 호출
    void test(){
        System.out.println("매개변수 없음");
    }
   
    // test에 매개변수로 int형 2개 호출
    void test(int a, int b){
        System.out.println("매개변수 "+ a + "와 " + b);
    }
   
    // test에 매개변수 double형 1개 호출
    void test(double d){
        System.out.println("매개변수 " + d);
    }
}

//오버라이딩
public class Employee{
   
    public String name;
    public int age;
   
    // print() 메소드
    public void print(){
        System.out.println("사원의 이름은 "+this.name+ "이고, 나이는" + this.age+"입니다.");
    }   
}
// Employee 상속
public class Manager extends Employee{
   
    String jobOfManage;
   
    // print() 메소드 오버라이딩
    public void print(){
        System.out.println("사원의 이름은 "+this.name + "이고, 나이는" + this.age + "입니다.");
        System.out.println("관리자 "+this.name+"은 "+this.jobOfManage+" 담당입니다.");
    }
}

```

### Call by Reference와 Call by Value의 차이

* **Call by Value**(값에 의한 호출)
  * 함수가 호출될 때, 메모리 공간 안에서는 함수를 위한 별도의 임시 공간이 생성된다.
  * 함수 호출시 인자로 전달되는 변수의 값을 복사하여 함수의 인자로 전달한다.
  * 복사된 인자는 함수 안에서 지역적으로 사용되는 local value의 특성을 가진다.
  * 따라서 함수 안에서 인자의 값이 변경되어도, 외부의 변수의 값은 변경되지 않는다.


* **Call by Reference** (참조에 의한 호출)
  * 함수가 호출될 때, 메모리 공간 안에서는 함수를 위한 별도의 임시 공간이 생성된다.
  * 함수 호출시 인자로 전달되는 변수의 레퍼런스를 전달한다. (해당 변수를 가리킨다.)
  * 따라서 함수 안에서 인자의 값이 변경되면, 인자로 전달된 변수의 값도 함께 변경된다.


* **따라서 Java는 항상 Call by Value 이다.(이부분 다시 정리해야 할듯, JAVA의 깊은복사, 얕은 복사)** 
    * 여기서 value 란?
      * 기본자료형의 값 또는 객체에 대한 레퍼런스
    * 기본자료형의 경우 해당하는 변수의 값을 복사해서 전달한다.
    * 참조자료형의 경우 해당하는 변수가 가지는 값이 레퍼런스이므로 인자로 넘길 때 Call by Value에 의해 변수가 가지고 있는 레퍼런스가 복사되어 전달된다.

### 업캐스팅 / 다운캐스팅

- 면접에서 잘나오는 상속 - 업캐스팅, 다운캐스팅 정리
```
자식클래스는 부모클래스의 모든 특성을 받습니다.
업캐스팅은 자식클래스의 객체가 부모클래스로 형변환하는걸 말하는데
부모형 클래스로 변환하면 그 이후에 자식클래스의 특성을 쓰면 컴파일 타임 오류납니다.

다운캐스팅은 자신의 고유 특성을 잃은 자식 클래스를 다시 원상태로 복구해주는겁니다.
업캐스팅된 것을 다시 돌려주는 겁니다.

즉, 다운캐스팅은 업캐스팅 된것을 다운캐스팅하여서 다시 자식클래스의 성질로 돌려주는겁니다.

1. 업캐스팅 먼저 선행
2.  다운캐스팅

* 바로 부모클래스의 객체를 자식클래스로 그냥 형변환할 경우는
 컴파일 시점에 오류가 발생하지않아도 런타임 오류를발생합니다. 
즉, 바로 다운캐스팅하는 경우는 오류를 발생하기때문에 쓰지않습니다.
```

### 크로스 컴파일러(cross compiler)
컴파일러가 실행되는 플랫폼이 아닌 다른 플랫폼에서 실행 가능한 코드를 생성할 수 있는 컴파일러이다.
크로스 컴파일러 툴은 임베디드 시스템 혹은 여러 플랫폼에서 실행파일을 생성하는데 사용된다.